# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `code_analyzer` gem.
# Please instead update this file by running `bin/tapioca gem code_analyzer`.

# source://code_analyzer//lib/code_analyzer/version.rb#3
module CodeAnalyzer; end

# source://code_analyzer//lib/code_analyzer/analyzer_exception.rb#4
class CodeAnalyzer::AnalyzerException < ::Exception; end

# A checker class that takes charge of checking the sexp.
#
# source://code_analyzer//lib/code_analyzer/checker.rb#5
class CodeAnalyzer::Checker
  # add an warning.
  #
  # @param message, [String] is the warning message
  # @param filename, [String] is the filename of source code
  # @param line_number, [Integer] is the line number of the source code which is reviewing
  #
  # source://code_analyzer//lib/code_analyzer/checker.rb#51
  def add_warning(message, filename = T.unsafe(nil), line_number = T.unsafe(nil)); end

  # interesting files that the check will parse.
  #
  # source://code_analyzer//lib/code_analyzer/checker.rb#12
  def interesting_files; end

  # interesting nodes that the check will parse.
  #
  # source://code_analyzer//lib/code_analyzer/checker.rb#7
  def interesting_nodes; end

  # delegate to end_### according to the sexp_type, like
  #
  #     end_call
  #     end_def
  #
  # @param node [Sexp]
  #
  # source://code_analyzer//lib/code_analyzer/checker.rb#41
  def node_end(node); end

  # delegate to start_### according to the sexp_type, like
  #
  #     start_call
  #     start_def
  #
  # @param node [Sexp]
  #
  # source://code_analyzer//lib/code_analyzer/checker.rb#30
  def node_start(node); end

  # check if the checker will parse the node file.
  #
  # @param the [String] file name of node.
  # @return [Boolean] true if the checker will parse the file.
  #
  # source://code_analyzer//lib/code_analyzer/checker.rb#20
  def parse_file?(node_file); end

  # all warnings.
  #
  # source://code_analyzer//lib/code_analyzer/checker.rb#56
  def warnings; end

  class << self
    # source://code_analyzer//lib/code_analyzer/checker.rb#76
    def add_callback(*names, &block); end

    # source://code_analyzer//lib/code_analyzer/checker.rb#83
    def callbacks; end

    # source://code_analyzer//lib/code_analyzer/checker.rb#71
    def get_callbacks(name); end

    # source://code_analyzer//lib/code_analyzer/checker.rb#66
    def interesting_files(*file_patterns); end

    # source://code_analyzer//lib/code_analyzer/checker.rb#61
    def interesting_nodes(*nodes); end
  end
end

# source://code_analyzer//lib/code_analyzer/checking_visitor.rb#4
module CodeAnalyzer::CheckingVisitor; end

# Base class for checking visitor.
#
# source://code_analyzer//lib/code_analyzer/checking_visitor/base.rb#5
class CodeAnalyzer::CheckingVisitor::Base
  # @return [Base] a new instance of Base
  #
  # source://code_analyzer//lib/code_analyzer/checking_visitor/base.rb#6
  def initialize(options = T.unsafe(nil)); end

  # source://code_analyzer//lib/code_analyzer/checking_visitor/base.rb#10
  def after_check; end

  # source://code_analyzer//lib/code_analyzer/checking_visitor/base.rb#12
  def warnings; end
end

# This is the default checking visitor to check ruby sexp nodes.
#
# source://code_analyzer//lib/code_analyzer/checking_visitor/default.rb#5
class CodeAnalyzer::CheckingVisitor::Default < ::CodeAnalyzer::CheckingVisitor::Base
  # @return [Default] a new instance of Default
  #
  # source://code_analyzer//lib/code_analyzer/checking_visitor/default.rb#6
  def initialize(options = T.unsafe(nil)); end

  # trigger all after_check callbacks defined in all checkers.
  #
  # source://code_analyzer//lib/code_analyzer/checking_visitor/default.rb#29
  def after_check; end

  # check the ruby sexp nodes for the ruby file.
  #
  # @param filename [String] is the filename of ruby code.
  # @param content [String] is the content of ruby file.
  #
  # source://code_analyzer//lib/code_analyzer/checking_visitor/default.rb#22
  def check(filename, content); end

  # recursively check ruby sexp node.
  #
  # 1. it triggers the interesting checkers' start callbacks.
  # 2. recursively check the sexp children.
  # 3. it triggers the interesting checkers' end callbacks.
  #
  # source://code_analyzer//lib/code_analyzer/checking_visitor/default.rb#51
  def check_node(node); end

  # parse ruby code.
  #
  # @param filename [String] is the filename of ruby code.
  # @param content [String] is the content of ruby file.
  #
  # source://code_analyzer//lib/code_analyzer/checking_visitor/default.rb#40
  def parse(filename, content); end
end

# This is the checking visitor to check ruby plain code.
#
# source://code_analyzer//lib/code_analyzer/checking_visitor/plain.rb#5
class CodeAnalyzer::CheckingVisitor::Plain < ::CodeAnalyzer::CheckingVisitor::Base
  # check the ruby plain code.
  #
  # @param filename [String] is the filename of ruby code.
  # @param content [String] is the content of ruby file.
  #
  # source://code_analyzer//lib/code_analyzer/checking_visitor/plain.rb#10
  def check(filename, content); end
end

# Fake nil.
#
# source://code_analyzer//lib/code_analyzer/nil.rb#5
class CodeAnalyzer::Nil
  # array_size is 0.
  #
  # source://code_analyzer//lib/code_analyzer/nil.rb#12
  def array_size; end

  # true
  #
  # @return [Boolean]
  #
  # source://code_analyzer//lib/code_analyzer/nil.rb#27
  def blank?; end

  # hash_size is 0.
  #
  # source://code_analyzer//lib/code_analyzer/nil.rb#7
  def hash_size; end

  # return self.
  #
  # source://code_analyzer//lib/code_analyzer/nil.rb#32
  def method_missing(method_sym, *arguments, &block); end

  # false
  #
  # @return [Boolean]
  #
  # source://code_analyzer//lib/code_analyzer/nil.rb#22
  def present?; end

  # return self for to_s.
  #
  # source://code_analyzer//lib/code_analyzer/nil.rb#17
  def to_s; end
end

# source://code_analyzer//lib/code_analyzer/version.rb#4
CodeAnalyzer::VERSION = T.let(T.unsafe(nil), String)

# Warning is the violation.
#
# it indicates the filenname, line number and error message for the violation.
#
# source://code_analyzer//lib/code_analyzer/warning.rb#7
class CodeAnalyzer::Warning
  # @return [Warning] a new instance of Warning
  #
  # source://code_analyzer//lib/code_analyzer/warning.rb#10
  def initialize(options = T.unsafe(nil)); end

  # Returns the value of attribute filename.
  #
  # source://code_analyzer//lib/code_analyzer/warning.rb#8
  def filename; end

  # Returns the value of attribute line_number.
  #
  # source://code_analyzer//lib/code_analyzer/warning.rb#8
  def line_number; end

  # Returns the value of attribute message.
  #
  # source://code_analyzer//lib/code_analyzer/warning.rb#8
  def message; end

  # source://code_analyzer//lib/code_analyzer/warning.rb#16
  def to_s; end
end

# source://code_analyzer//lib/code_analyzer/sexp.rb#5
class Sexp < ::Array
  # source://sexp_processor/4.17.1/lib/sexp.rb#35
  def initialize(*args); end

  # source://sexp_processor/4.17.1/lib/sexp_matcher.rb#30
  def /(pattern); end

  # source://sexp_processor/4.17.1/lib/sexp.rb#76
  def ==(obj); end

  # source://sexp_processor/4.17.1/lib/sexp_matcher.rb#8
  def =~(pattern); end

  def _concat(*_arg0); end

  # Get all arguments.
  #
  #     s(:args_add_block,
  #       s(:args_add,
  #         s(:args_add, s(:args_new), s(:string_literal, s(:string_add, s(:string_content), s(:@tstring_content, "hello", s(1, 6))))),
  #         s(:string_literal, s(:string_add, s(:string_content), s(:@tstring_content, "world", s(1, 15))))
  #       ), false
  #     )
  #         => [
  #              s(:args_add, s(:args_new), s(:string_literal, s(:string_add, s(:string_content), s(:@tstring_content, "hello", s(1, 6))))),
  #              s(:string_literal, s(:string_add, s(:string_content), s(:@tstring_content, "world", s(1, 15))))
  #            ]
  #
  # @return [Array] all arguments
  #
  # source://code_analyzer//lib/code_analyzer/sexp.rb#299
  def all; end

  # Get all condition nodes.
  #
  #     s(:binary,
  #       s(:binary,
  #         s(:var_ref, s(:@ident, "user", s(1, 0))),
  #         :==,
  #         s(:var_ref, s(:@ident, "current_user", s(1, 8)))
  #       ),
  #       :"&&",
  #       s(:call,
  #         s(:var_ref, s(:@ident, "user", s(1, 24))),
  #         :".",
  #         s(:@ident, "valid?", s(1, 29))
  #       )
  #     )
  #         => [
  #              s(:binary,
  #                s(:var_ref, s(:@ident, "user", s(1, 0))),
  #                :==,
  #                s(:var_ref, s(:@ident, "current_user", s(1, 8)))
  #              ),
  #              s(:call,
  #                s(:var_ref, s(:@ident, "user", s(1, 24))),
  #                  :".",
  #                  s(:@ident, "valid?", s(1, 29))
  #              )
  #            ]
  #
  # @return [Array] all condition nodes
  #
  # source://code_analyzer//lib/code_analyzer/sexp.rb#365
  def all_conditions; end

  # Get only argument for binary.
  #
  #     s(:binary,
  #       s(:var_ref, s(:@ident, "user", s(1, 0))),
  #       :==,
  #       s(:var_ref, s(:@ident, "current_user", s(1, 8)))
  #     )
  #         => s(:var_ref, s(:@ident, "current_user", s(1, 8)))
  #
  # @return [Sexp] argument node
  def argument; end

  # Get arguments node.
  #
  #     s(:command,
  #       s(:@ident, "resources", s(1, 0)),
  #       s(:args_add_block,
  #         s(:args_add, s(:args_new),
  #           s(:symbol_literal, s(:symbol, s(:@ident, "posts", s(1, 11))))
  #         ), false
  #       )
  #     )
  #         => s(:args_add_block,
  #              s(:args_add, s(:args_new),
  #                s(:symbol_literal, s(:symbol, s(:@ident, "posts", s(1, 11))))
  #              ), false
  #            )
  #
  # @return [Sexp] arguments node
  def arguments; end

  # Get the array size.
  #
  #     s(:array,
  #       s(:args_add,
  #         s(:args_add, s(:args_new), s(:string_literal, s(:string_add, s(:string_content), s(:@tstring_content, "first_name", s(1, 2))))),
  #         s(:string_literal, s(:string_add, s(:string_content), s(:@tstring_content, "last_name", s(1, 16))))
  #       )
  #     )
  #         => 2
  #
  # @return [Integer] array size
  #
  # source://code_analyzer//lib/code_analyzer/sexp.rb#727
  def array_size; end

  # source://sexp_processor/4.17.1/lib/sexp.rb#93
  def array_type?; end

  # Get the array values.
  #
  #     s(:array,
  #       s(:args_add,
  #         s(:args_add, s(:args_new), s(:string_literal, s(:string_add, s(:string_content), s(:@tstring_content, "first_name", s(1, 2))))),
  #         s(:string_literal, s(:string_add, s(:string_content), s(:@tstring_content, "last_name", s(1, 16))))
  #       )
  #     )
  #         => [
  #              s(:string_literal, s(:string_add, s(:string_content), s(:@tstring_content, "first_name", s(1, 2)))),
  #              s(:string_literal, s(:string_add, s(:string_content), s(:@tstring_content, "last_name", s(1, 16))))
  #            ]
  #
  # @return [Array] array values
  #
  # source://code_analyzer//lib/code_analyzer/sexp.rb#759
  def array_values; end

  # Get the base class of the class node.
  #
  #     s(:class,
  #       s(:const_ref, s(:@const, "User", s(1, 6))),
  #       s(:const_path_ref, s(:var_ref, s(:@const, "ActiveRecord", s(1, 13))), s(:@const, "Base", s(1, 27))),
  #       s(:bodystmt, s(:stmts_add, s(:stmts_new), s(:void_stmt)), nil, nil, nil)
  #     )
  #         => s(:const_path_ref, s(:var_ref, s(:@const, "ActiveRecord", s(1, 13))), s(:@const, "Base", s(1, 27))),
  #
  # @return [Sexp] base class of class node
  def base_class; end

  # false
  #
  # @return [Boolean]
  #
  # source://code_analyzer//lib/code_analyzer/sexp.rb#870
  def blank?; end

  # Get block node.
  #
  #     s(:method_add_block,
  #       s(:command,
  #         s(:@ident, "resources", s(1, 0)),
  #         s(:args_add_block, s(:args_add, s(:args_new), s(:symbol_literal, s(:symbol, s(:@ident, "posts", s(1, 11))))), false)
  #       ),
  #       s(:do_block, nil,
  #         s(:stmts_add, s(:stmts_add, s(:stmts_new), s(:void_stmt)),
  #           s(:command,
  #           s(:@ident, "resources", s(1, 21)),
  #           s(:args_add_block, s(:args_add, s(:args_new), s(:symbol_literal, s(:symbol, s(:@ident, "comments", s(1, 32))))), false))
  #         )
  #       )
  #     )
  #         => s(:do_block, nil,
  #              s(:stmts_add, s(:stmts_add, s(:stmts_new), s(:void_stmt)),
  #                s(:command,
  #                s(:@ident, "resources", s(1, 21)),
  #                s(:args_add_block, s(:args_add, s(:args_new), s(:symbol_literal, s(:symbol, s(:@ident, "comments", s(1, 32))))), false))
  #              )
  #            )
  #
  # @return [Sexp] body node
  def block_node; end

  # source://ruby_parser/3.21.0/lib/rp_extensions.rb#47
  def block_pass?; end

  # Get body node.
  #
  #     s(:class,
  #       s(:const_ref, s(:@const, "User", s(1, 6))),
  #       nil,
  #       s(:bodystmt,
  #         s(:stmts_add, s(:stmts_new),
  #           s(:def,
  #             s(:@ident, "login", s(1, 16)),
  #             s(:params, nil, nil, nil, nil, nil),
  #             s(:bodystmt, s(:stmts_add, s(:stmts_new), s(:void_stmt)), nil, nil, nil)
  #           )
  #         ), nil, nil, nil
  #       )
  #     )
  #         => s(:bodystmt,
  #              s(:stmts_add, s(:stmts_new),
  #                s(:def,
  #                  s(:@ident, "login", s(1, 16)),
  #                  s(:params, nil, nil, nil, nil, nil),
  #                  s(:bodystmt, s(:stmts_add, s(:stmts_new), s(:void_stmt)), nil, nil, nil)
  #                )
  #              ), nil, nil, nil
  #            )
  #
  # @return [Sexp] body node
  def body; end

  # check current node.
  #
  # @param visitor [CodeAnalyzer::CheckingVisitor::Default] the visitor to check current node
  #
  # source://code_analyzer//lib/code_analyzer/sexp.rb#9
  def check(visitor); end

  # source://ruby_parser/3.21.0/lib/ruby_parser_extras.rb#12
  def check_line_numbers; end

  # return child nodes of a sexp node.
  #
  # @return [Array] child nodes.
  #
  # source://code_analyzer//lib/code_analyzer/sexp.rb#42
  def children; end

  # Get the class name of the class node.
  #
  #     s(:class,
  #       s(:const_ref, s(:@const, "User", s(1, 6))),
  #       nil,
  #       s(:bodystmt, s(:stmts_add, s(:stmts_new), s(:void_stmt)), nil, nil, nil)
  #     )
  #         => s(:const_ref, s(:@const, "User", s(1, 6))),
  #
  # @return [Sexp] class name node
  def class_name; end

  # source://sexp_processor/4.17.1/lib/sexp.rb#28
  def comments; end

  # source://sexp_processor/4.17.1/lib/sexp.rb#28
  def comments=(_arg0); end

  # source://sexp_processor/4.17.1/lib/sexp.rb#99
  def compact; end

  # Get the conditional statement of if node.
  #
  #     s(:if,
  #       s(:var_ref, s(:@kw, "true", s(1, 3))),
  #       s(:stmts_add, s(:stmts_new), s(:void_stmt)),
  #       nil
  #     )
  #         => s(:var_ref, s(:@kw, "true", s(1, 3))),
  #
  # @return [Sexp] conditional statement of if node
  def conditional_statement; end

  # check if the self node is a const.
  #
  # @return [Boolean]
  #
  # source://code_analyzer//lib/code_analyzer/sexp.rb#860
  def const?; end

  # source://sexp_processor/4.17.1/lib/sexp.rb#113
  def deep_each(&block); end

  # source://sexp_processor/4.17.1/lib/sexp.rb#125
  def depth; end

  # source://sexp_processor/4.17.1/lib/sexp.rb#132
  def each_of_type(t, &b); end

  # source://sexp_processor/4.17.1/lib/sexp.rb#144
  def each_sexp; end

  # source://sexp_processor/4.17.1/lib/sexp.rb#80
  def eql?(o); end

  # Get expcetion class of rescue node.
  #
  #     s(:rescue,
  #       s(
  #         s(:var_ref,
  #           s(:@const, "CustomException", s(1, 17))
  #         )
  #       ),
  #       nil,
  #       s(:stmts_add, s(:stmts_new), s(:void_stmt)),
  #       nil
  #     )
  #         => s(s(:var_ref, s(:@const, "CustomException", s(1, 17))))
  #
  # source://code_analyzer//lib/code_analyzer/sexp.rb#545
  def exception_classes; end

  # Get exception variable of rescue node.
  #
  #     s(:rescue,
  #       nil,
  #       s(:var_field, s(:@ident, "e", s(1, 20))),
  #       s(:stmts_add, s(:stmts_new), s(:void_stmt)),
  #       nil
  #     )
  #         => s(:var_field, s(:@ident, "e", s(1, 20)))
  #
  # source://code_analyzer//lib/code_analyzer/sexp.rb#572
  def exception_variable; end

  # source://sexp_processor/4.17.1/lib/sexp.rb#23
  def file; end

  # source://sexp_processor/4.17.1/lib/sexp.rb#23
  def file=(_arg0); end

  # source://sexp_processor/4.17.1/lib/sexp.rb#158
  def find_and_replace_all(from, to); end

  # source://sexp_processor/4.17.1/lib/sexp.rb#199
  def find_node(name, delete = T.unsafe(nil)); end

  # source://sexp_processor/4.17.1/lib/sexp.rb#217
  def find_nodes(name); end

  # grep all the recursive child nodes with conditions, and yield the first match node.
  #
  # options is the grep conditions, like
  #
  #     sexp_type: :call,
  #     receiver: s(:const, Post),
  #     message: [:find, :new]
  #
  # the condition key is one of :sexp_type, :receiver, :message, and to_s,
  # the condition value can be Symbol, Array or Sexp.
  #
  # @param options [Hash] grep conditions
  #
  # source://code_analyzer//lib/code_analyzer/sexp.rb#101
  def grep_node(options); end

  # grep all the recursive child nodes with conditions, and yield each match node.
  #
  # options is the grep conditions, like
  #
  #     sexp_type: :call,
  #     receiver: "Post",
  #     message: ["find", "new"]
  #     to_s: "devise"
  #
  # the condition key is one of :sexp_type, :receiver, :message, :to_s,
  # the condition value can be Symbol, Array or Sexp.
  #
  # @param options [Hash] grep conditions
  #
  # source://code_analyzer//lib/code_analyzer/sexp.rb#67
  def grep_nodes(options); end

  # grep all the recursive child nodes with conditions, and get the count of match nodes.
  #
  # @param options [Hash] grep conditions
  # @return [Integer] the count of metch nodes
  #
  # source://code_analyzer//lib/code_analyzer/sexp.rb#114
  def grep_nodes_count(options); end

  # source://sexp_processor/4.17.1/lib/sexp.rb#171
  def gsub(pattern, repl); end

  # source://sexp_processor/4.17.1/lib/sexp.rb#84
  def hash; end

  # Get the hash keys.
  #
  #     s(:hash,
  #       s(:assoclist_from_args,
  #         s(
  #           s(:assoc_new, s(:@label, "first_name:", s(1, 1)), s(:string_literal, s(:string_add, s(:string_content), s(:@tstring_content, "Richard", s(1, 14))))),
  #           s(:assoc_new, s(:@label, "last_name:", s(1, 24)), s(:string_literal, s(:string_add, s(:string_content), s(:@tstring_content, "Huang", s(1, 36)))))
  #         )
  #       )
  #     )
  #         => ["first_name", "last_name"]
  #
  # @return [Array] hash keys
  #
  # source://code_analyzer//lib/code_analyzer/sexp.rb#641
  def hash_keys; end

  # Get hash size.
  #
  #     s(:hash,
  #       s(:assoclist_from_args,
  #         s(
  #           s(:assoc_new, s(:@label, "first_name:", s(1, 1)), s(:string_literal, s(:string_add, s(:string_content), s(:@tstring_content, "Richard", s(1, 14))))),
  #           s(:assoc_new, s(:@label, "last_name:", s(1, 24)), s(:string_literal, s(:string_add, s(:string_content), s(:@tstring_content, "Huang", s(1, 36)))))
  #         )
  #       )
  #     )
  #         => 2
  #
  # @return [Integer] hash size
  #
  # source://code_analyzer//lib/code_analyzer/sexp.rb#617
  def hash_size; end

  # Get hash value node.
  #
  #     s(:hash,
  #       s(:assoclist_from_args,
  #         s(
  #           s(:assoc_new, s(:@label, "first_name:", s(1, 1)), s(:string_literal, s(:string_add, s(:string_content), s(:@tstring_content, "Richard", s(1, 14))))),
  #           s(:assoc_new, s(:@label, "last_name:", s(1, 24)), s(:string_literal, s(:string_add, s(:string_content), s(:@tstring_content, "Huang", s(1, 36)))))
  #         )
  #       )
  #     )
  #         => s(:string_literal, s(:string_add, s(:string_content), s(:@tstring_content, "Richard", s(1, 14))))
  #
  # @return [Sexp] hash value node
  #
  # source://code_analyzer//lib/code_analyzer/sexp.rb#589
  def hash_value(key); end

  # Get the hash values.
  #
  #     s(:hash,
  #       s(:assoclist_from_args,
  #         s(
  #           s(:assoc_new, s(:@label, "first_name:", s(1, 1)), s(:string_literal, s(:string_add, s(:string_content), s(:@tstring_content, "Richard", s(1, 14))))),
  #           s(:assoc_new, s(:@label, "last_name:", s(1, 24)), s(:string_literal, s(:string_add, s(:string_content), s(:@tstring_content, "Huang", s(1, 36)))))
  #         )
  #       )
  #     )
  #         => [
  #              s(:string_literal, s(:string_add, s(:string_content), s(:@tstring_content, "Richard", s(1, 14)))),
  #              s(:string_literal, s(:string_add, s(:string_content), s(:@tstring_content, "Huang", s(1, 36))))
  #            ]
  #
  # @return [Array] hash values
  #
  # source://code_analyzer//lib/code_analyzer/sexp.rb#674
  def hash_values; end

  # source://sexp_processor/4.17.1/lib/sexp.rb#284
  def head; end

  # source://sexp_processor/4.17.1/lib/sexp.rb#190
  def inspect; end

  # Get the hash key
  #
  #     s(:assoc_new, s(:@label, "first_name:", s(1, 1)), s(:string_literal, s(:string_add, s(:string_content), s(:@tstring_content, "Richard", s(1, 14)))))
  #     =>
  #     s(:@label, "first_name:", s(1, 1))
  #
  # source://code_analyzer//lib/code_analyzer/sexp.rb#696
  def key; end

  # Get the left value of the assign node.
  #
  #     s(:assign,
  #       s(:var_field, s(:@ident, "user", s(1, 0))),
  #       s(:var_ref, s(:@ident, "current_user", s(1, 7)))
  #     )
  #         => s(:var_field, s(:@ident, "user", s(1, 0))),
  #
  # @return [Symbol] left value of lasgn or iasgn node
  def left_value; end

  # source://sexp_processor/4.17.1/lib/sexp.rb#228
  def line(n = T.unsafe(nil)); end

  # source://sexp_processor/4.17.1/lib/sexp.rb#13
  def line=(_arg0); end

  # source://sexp_processor/4.17.1/lib/sexp.rb#241
  def line_max; end

  # source://sexp_processor/4.17.1/lib/sexp.rb#18
  def line_max=(_arg0); end

  # source://ruby_parser/3.21.0/lib/ruby_parser_extras.rb#23
  def line_min; end

  # return the line number of a sexp node.
  #
  #     s(:@ident, "test", s(2, 12)
  #       => 2
  #
  # source://code_analyzer//lib/code_analyzer/sexp.rb#18
  def line_number; end

  # source://sexp_processor/4.17.1/lib/sexp.rb#72
  def map(&blk); end

  # source://sexp_processor/4.17.1/lib/sexp.rb#248
  def mass; end

  # Get the message node.
  #
  #     s(:command,
  #       s(:@ident, "has_many", s(1, 0)),
  #       s(:args_add_block,
  #         s(:args_add, s(:args_new),
  #           s(:symbol_literal, s(:symbol, s(:@ident, "projects", s(1, 10))))
  #         ),
  #         false
  #       )
  #     )
  #         => s(:@ident, "has_many", s(1, 0)),
  #
  # @return [Symbol] message node
  def message; end

  # source://sexp_processor/4.17.1/lib/sexp.rb#255
  def method_missing(meth, delete = T.unsafe(nil)); end

  # Get the method name of def node.
  #
  #     s(:def,
  #       s(:@ident, "show", s(1, 4)),
  #       s(:params, nil, nil, nil, nil, nil),
  #       s(:bodystmt, s(:stmts_add, s(:stmts_new), s(:void_stmt)), nil, nil, nil)
  #     )
  #         => s(:@ident, "show", s(1, 4)),
  #
  # @return [Sexp] method name node
  def method_name; end

  # Get the module name of the module node.
  #
  #     s(:module,
  #       s(:const_ref, s(:@const, "Admin", s(1, 7))),
  #       s(:bodystmt, s(:stmts_add, s(:stmts_new), s(:void_stmt)), nil, nil, nil)
  #     )
  #         => s(:const_ref, s(:@const, "Admin", s(1, 7))),
  #
  # @return [Sexp] module name node
  #
  # source://code_analyzer//lib/code_analyzer/sexp.rb#152
  def module_name; end

  # source://sexp_processor/4.17.1/lib/sexp.rb#63
  def new(*body); end

  # new method for alias node.
  #
  #     s(:alias,
  #       s(:symbol_literal, s(:@ident, "new", s(1, 6))),
  #       s(:symbol_literal, s(:@ident, "old", s(1, 10)))
  #     )
  #         => s(:symbol_literal, s(:@ident, "new", s(1, 6))),
  #
  # source://code_analyzer//lib/code_analyzer/sexp.rb#804
  def new_method; end

  # source://ruby_parser/3.21.0/lib/ruby_parser_extras.rb#27
  def nil_line?; end

  # old method for alias node.
  #
  #     s(:alias,
  #       s(:symbol_literal, s(:@ident, "new", s(1, 6))),
  #       s(:symbol_literal, s(:@ident, "old", s(1, 10)))
  #     )
  #         => s(:symbol_literal, s(:@ident, "old", s(1, 10))),
  #
  # source://code_analyzer//lib/code_analyzer/sexp.rb#793
  def old_method; end

  # source://code_analyzer//lib/code_analyzer/sexp.rb#281
  def origin_argument; end

  # source://code_analyzer//lib/code_analyzer/sexp.rb#254
  def origin_arguments; end

  # source://code_analyzer//lib/code_analyzer/sexp.rb#180
  def origin_base_class; end

  # source://code_analyzer//lib/code_analyzer/sexp.rb#469
  def origin_block_node; end

  # source://code_analyzer//lib/code_analyzer/sexp.rb#432
  def origin_body; end

  # source://code_analyzer//lib/code_analyzer/sexp.rb#166
  def origin_class_name; end

  # source://code_analyzer//lib/code_analyzer/sexp.rb#332
  def origin_conditional_statement; end

  # source://code_analyzer//lib/code_analyzer/sexp.rb#193
  def origin_left_value; end

  # source://code_analyzer//lib/code_analyzer/sexp.rb#224
  def origin_message; end

  # source://code_analyzer//lib/code_analyzer/sexp.rb#394
  def origin_method_name; end

  # source://code_analyzer//lib/code_analyzer/sexp.rb#134
  def origin_receiver; end

  # source://code_analyzer//lib/code_analyzer/sexp.rb#206
  def origin_right_value; end

  # source://sexp_processor/4.17.1/lib/sexp.rb#284
  def origin_sexp_type; end

  # source://ruby_parser/3.21.0/lib/rp_extensions.rb#43
  def paren; end

  # source://ruby_parser/3.21.0/lib/rp_extensions.rb#41
  def paren=(_arg0); end

  # true
  #
  # @return [Boolean]
  #
  # source://code_analyzer//lib/code_analyzer/sexp.rb#865
  def present?; end

  # source://sexp_processor/4.17.1/lib/sexp.rb#272
  def pretty_print(q); end

  # Get receiver node.
  #
  #     s(:call,
  #       s(:var_ref,
  #         s(:@ident, "user", s(1, 0))
  #       ),
  #       :".",
  #       s(:@ident, "name", s(1, 5))
  #     )
  #         => s(:var_ref,
  #              s(:@ident, "user", s(1, 0))
  #            )
  #
  # @return [Sexp] receiver node
  def receiver; end

  # recursively find all child nodes, and yeild each child node.
  #
  # source://code_analyzer//lib/code_analyzer/sexp.rb#47
  def recursive_children; end

  # remove the line and column info from sexp.
  #
  # source://code_analyzer//lib/code_analyzer/sexp.rb#875
  def remove_line_and_column; end

  # source://sexp_processor/4.17.1/lib/sexp_matcher.rb#57
  def replace_sexp(pattern, &block); end

  # source://sexp_processor/4.17.1/lib/sexp.rb#267
  def respond_to?(msg, private = T.unsafe(nil)); end

  # source://sexp_processor/4.17.1/lib/sexp.rb#299
  def rest(from = T.unsafe(nil)); end

  # Get the right value of assign node.
  #
  #     s(:assign,
  #       s(:var_field, s(:@ident, "user", s(1, 0))),
  #       s(:var_ref, s(:@ident, "current_user", s(1, 7)))
  #     )
  #         => s(:var_ref, s(:@ident, "current_user", s(1, 7)))
  #
  # @return [Sexp] right value of assign node
  def right_value; end

  # source://sexp_processor/4.17.1/lib/sexp_matcher.rb#19
  def satisfy?(pattern); end

  # source://sexp_processor/4.17.1/lib/sexp_matcher.rb#38
  def search_each(pattern, &block); end

  # source://sexp_processor/4.17.1/lib/sexp.rb#299
  def sexp_body(from = T.unsafe(nil)); end

  # source://sexp_processor/4.17.1/lib/sexp.rb#306
  def sexp_body=(v); end

  def sexp_type; end

  # source://sexp_processor/4.17.1/lib/sexp.rb#291
  def sexp_type=(v); end

  # Get all statements nodes.
  #
  #     s(:bodystmt,
  #       s(:stmts_add,
  #         s(:stmts_add, s(:stmts_new),
  #           s(:def,
  #             s(:@ident, "login?", s(1, 16)),
  #             s(:params, nil, nil, nil, nil, nil),
  #             s(:bodystmt, s(:stmts_add, s(:stmts_new), s(:void_stmt)), nil, nil, nil)
  #           )
  #         ),
  #         s(:def,
  #           s(:@ident, "admin?", s(1, 33)),
  #           s(:params, nil, nil, nil, nil, nil),
  #           s(:bodystmt, s(:stmts_add, s(:stmts_new), s(:void_stmt)), nil, nil, nil)
  #         )
  #       ), nil, nil, nil
  #     )
  #         => [
  #              s(:def,
  #                s(:@ident, "login?", s(1, 16)),
  #                s(:params, nil, nil, nil, nil, nil),
  #                s(:bodystmt, s(:stmts_add, s(:stmts_new), s(:void_stmt)), nil, nil, nil)
  #              ),
  #              s(:def,
  #                s(:@ident, "admin?", s(1, 33)),
  #                s(:params, nil, nil, nil, nil, nil),
  #                s(:bodystmt, s(:stmts_add, s(:stmts_new), s(:void_stmt)), nil, nil, nil)
  #              )
  #            ]
  #
  # @return [Array] all statements
  #
  # source://code_analyzer//lib/code_analyzer/sexp.rb#508
  def statements; end

  # source://sexp_processor/4.17.1/lib/sexp.rb#326
  def structure; end

  # source://sexp_processor/4.17.1/lib/sexp.rb#338
  def sub(pattern, repl); end

  # source://sexp_processor/4.17.1/lib/sexp.rb#368
  def to_a; end

  # To object.
  #
  #     s(:array,
  #       s(:args_add,
  #         s(:args_add, s(:args_new), s(:string_literal, s(:string_add, s(:string_content), s(:@tstring_content, "first_name", s(1, 2))))),
  #         s(:string_literal, s(:string_add, s(:string_content), s(:@tstring_content, "last_name", s(1, 16))))
  #       )
  #     )
  #         => ["first_name", "last_name"]
  #
  # @return [Object]
  #
  # source://code_analyzer//lib/code_analyzer/sexp.rb#819
  def to_object; end

  # to_s.
  #
  # @return [String] to_s
  #
  # source://code_analyzer//lib/code_analyzer/sexp.rb#831
  def to_s; end

  # Get the hash value
  #
  #     s(:assoc_new, s(:@label, "first_name:", s(1, 1)), s(:string_literal, s(:string_add, s(:string_content), s(:@tstring_content, "Richard", s(1, 14)))))
  #     =>
  #     s(:string_literal, s(:string_add, s(:string_content), s(:@tstring_content, "Richard", s(1, 14))))
  #
  # source://code_analyzer//lib/code_analyzer/sexp.rb#707
  def value; end

  class << self
    # source://sexp_processor/4.17.1/lib/sexp_matcher.rb#155
    def -(arg); end

    # source://sexp_processor/4.17.1/lib/sexp_matcher.rb#93
    def _; end

    # source://sexp_processor/4.17.1/lib/sexp_matcher.rb#104
    def ___; end

    # source://sexp_processor/4.17.1/lib/sexp_matcher.rb#144
    def all(*args); end

    # source://sexp_processor/4.17.1/lib/sexp_matcher.rb#133
    def any(*args); end

    # source://sexp_processor/4.17.1/lib/sexp_matcher.rb#122
    def atom; end

    # source://sexp_processor/4.17.1/lib/sexp_matcher.rb#170
    def child(child); end

    # source://sexp_processor/4.17.1/lib/sexp.rb#44
    def from_array(a); end

    # source://sexp_processor/4.17.1/lib/sexp_matcher.rb#113
    def include(child); end

    # source://sexp_processor/4.17.1/lib/sexp_matcher.rb#208
    def k(klass); end

    # source://sexp_processor/4.17.1/lib/sexp_matcher.rb#190
    def m(*values); end

    # source://sexp_processor/4.17.1/lib/sexp_matcher.rb#155
    def not?(arg); end

    # source://sexp_processor/4.17.1/lib/sexp_matcher.rb#78
    def q(*args); end

    # source://sexp_processor/4.17.1/lib/sexp_matcher.rb#82
    def s(*args); end

    # source://sexp_processor/4.17.1/lib/sexp_matcher.rb#180
    def t(name); end
  end
end
