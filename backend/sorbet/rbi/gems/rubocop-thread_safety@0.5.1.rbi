# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rubocop-thread_safety` gem.
# Please instead update this file by running `bin/tapioca gem rubocop-thread_safety`.

# source://rubocop-thread_safety//lib/rubocop/thread_safety.rb#3
module RuboCop; end

# source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/instance_variable_in_class_method.rb#4
module RuboCop::Cop; end

# source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/instance_variable_in_class_method.rb#5
module RuboCop::Cop::ThreadSafety; end

# Avoid mutating class and module attributes.
#
# They are implemented by class variables, which are not thread-safe.
#
# @example
#   # bad
#   class User
#   cattr_accessor :current_user
#   end
#
# source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_and_module_attributes.rb#15
class RuboCop::Cop::ThreadSafety::ClassAndModuleAttributes < ::RuboCop::Cop::Base
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_and_module_attributes.rb#32
  def attr?(param0 = T.unsafe(nil)); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_and_module_attributes.rb#39
  def attr_internal?(param0 = T.unsafe(nil)); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_and_module_attributes.rb#46
  def class_attr?(param0 = T.unsafe(nil)); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_and_module_attributes.rb#25
  def mattr?(param0 = T.unsafe(nil)); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_and_module_attributes.rb#52
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_and_module_attributes.rb#66
  def defined_in_singleton_class?(node); end

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_and_module_attributes.rb#61
  def singleton_attr?(node); end
end

# source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_and_module_attributes.rb#16
RuboCop::Cop::ThreadSafety::ClassAndModuleAttributes::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/class_and_module_attributes.rb#17
RuboCop::Cop::ThreadSafety::ClassAndModuleAttributes::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Avoid instance variables in class methods.
#
# @example
#   # bad
#   class User
#   def self.notify(info)
#   @info = validate(info)
#   Notifier.new(@info).deliver
#   end
#   end
#
#   class Model
#   class << self
#   def table_name(name)
#   @table_name = name
#   end
#   end
#   end
#
#   class Host
#   %i[uri port].each do |key|
#   define_singleton_method("#{key}=") do |value|
#   instance_variable_set("@#{key}", value)
#   end
#   end
#   end
#
#   module Example
#   module ClassMethods
#   def test(params)
#   @params = params
#   end
#   end
#   end
#
#   module Example
#   class_methods do
#   def test(params)
#   @params = params
#   end
#   end
#   end
#
#   module Example
#   module_function
#
#   def test(params)
#   @params = params
#   end
#   end
#
#   module Example
#   def test(params)
#   @params = params
#   end
#
#   module_function :test
#   end
#
# source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/instance_variable_in_class_method.rb#64
class RuboCop::Cop::ThreadSafety::InstanceVariableInClassMethod < ::RuboCop::Cop::Base
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/instance_variable_in_class_method.rb#194
  def class_methods_module?(param0 = T.unsafe(nil)); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/instance_variable_in_class_method.rb#77
  def instance_variable_get_call?(param0 = T.unsafe(nil)); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/instance_variable_in_class_method.rb#72
  def instance_variable_set_call?(param0 = T.unsafe(nil)); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/instance_variable_in_class_method.rb#199
  def module_function_for?(param0 = T.unsafe(nil), param1); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/instance_variable_in_class_method.rb#81
  def on_ivar(node); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/instance_variable_in_class_method.rb#81
  def on_ivasgn(node); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/instance_variable_in_class_method.rb#90
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/instance_variable_in_class_method.rb#101
  def class_method_definition?(node); end

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/instance_variable_in_class_method.rb#121
  def in_def_class_methods?(node); end

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/instance_variable_in_class_method.rb#125
  def in_def_class_methods_dsl?(node); end

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/instance_variable_in_class_method.rb#134
  def in_def_class_methods_module?(node); end

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/instance_variable_in_class_method.rb#146
  def in_def_module_function?(node); end

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/instance_variable_in_class_method.rb#115
  def in_def_sclass?(node); end

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/instance_variable_in_class_method.rb#111
  def in_defs?(node); end

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/instance_variable_in_class_method.rb#179
  def instance_variable_call?(node); end

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/instance_variable_in_class_method.rb#189
  def match_name?(arg_name, method_name); end

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/instance_variable_in_class_method.rb#162
  def method_definition?(node); end

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/instance_variable_in_class_method.rb#183
  def module_function_bare_access_modifier?(node); end

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/instance_variable_in_class_method.rb#154
  def singleton_method_definition?(node); end

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/instance_variable_in_class_method.rb#170
  def synchronized?(node); end
end

# source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/instance_variable_in_class_method.rb#65
RuboCop::Cop::ThreadSafety::InstanceVariableInClassMethod::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/instance_variable_in_class_method.rb#66
RuboCop::Cop::ThreadSafety::InstanceVariableInClassMethod::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks whether some class instance variable isn't a
# mutable literal (e.g. array or hash).
#
# It is based on Style/MutableConstant from RuboCop.
# See https://github.com/rubocop-hq/rubocop/blob/master/lib/rubocop/cop/style/mutable_constant.rb
#
# Class instance variables are a risk to threaded code as they are shared
# between threads. A mutable object such as an array or hash may be
# updated via an attr_reader so would not be detected by the
# ThreadSafety/ClassAndModuleAttributes cop.
#
# Strict mode can be used to freeze all class instance variables, rather
# than just literals.
# Strict mode is considered an experimental feature. It has not been
# updated with an exhaustive list of all methods that will produce frozen
# objects so there is a decent chance of getting some false positives.
# Luckily, there is no harm in freezing an already frozen object.
#
# @example EnforcedStyle: literals (default)
#   # bad
#   class Model
#   @list = [1, 2, 3]
#   end
#
#   # good
#   class Model
#   @list = [1, 2, 3].freeze
#   end
#
#   # good
#   class Model
#   @var = <<~TESTING.freeze
#   This is a heredoc
#   TESTING
#   end
#
#   # good
#   class Model
#   @var = Something.new
#   end
# @example EnforcedStyle: strict
#   # bad
#   class Model
#   @var = Something.new
#   end
#
#   # bad
#   class Model
#   @var = Struct.new do
#   def foo
#   puts 1
#   end
#   end
#   end
#
#   # good
#   class Model
#   @var = Something.new.freeze
#   end
#
#   # good
#   class Model
#   @var = Struct.new do
#   def foo
#   puts 1
#   end
#   end.freeze
#   end
#
# source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#75
class RuboCop::Cop::ThreadSafety::MutableClassInstanceVariable < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#112
  def autocorrect(corrector, node); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#218
  def define_method?(param0 = T.unsafe(nil)); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#213
  def define_singleton_method?(param0 = T.unsafe(nil)); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#84
  def on_ivasgn(node); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#99
  def on_masgn(node); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#91
  def on_or_asgn(node); end

  # NOTE: Some of these patterns may not actually return an immutable
  # object but we will consider them immutable for this cop.
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#230
  def operation_produces_immutable_object?(param0 = T.unsafe(nil)); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#247
  def operation_produces_threadsafe_object?(param0 = T.unsafe(nil)); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#280
  def range_enclosed_in_parentheses?(param0 = T.unsafe(nil)); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#223
  def splat_value(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#159
  def check(value); end

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#178
  def container?(node); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#204
  def correct_splat_expansion(corrector, expr, splat_value); end

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#131
  def frozen_string_literal?(node); end

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#191
  def immutable_literal?(node); end

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#169
  def in_class?(node); end

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#185
  def mutable_literal?(node); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#140
  def on_assignment(value); end

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#200
  def range_type?(node); end

  # @return [Boolean]
  #
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#195
  def requires_parentheses?(node); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#148
  def strict_check(value); end
end

# source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#81
RuboCop::Cop::ThreadSafety::MutableClassInstanceVariable::FROZEN_STRING_LITERAL_TYPES_RUBY27 = T.let(T.unsafe(nil), Array)

# source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#82
RuboCop::Cop::ThreadSafety::MutableClassInstanceVariable::FROZEN_STRING_LITERAL_TYPES_RUBY30 = T.let(T.unsafe(nil), Array)

# source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/mutable_class_instance_variable.rb#80
RuboCop::Cop::ThreadSafety::MutableClassInstanceVariable::MSG = T.let(T.unsafe(nil), String)

# Avoid starting new threads.
#
# Let a framework like Sidekiq handle the threads.
#
# @example
#   # bad
#   Thread.new { do_work }
#
# source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/new_thread.rb#13
class RuboCop::Cop::ThreadSafety::NewThread < ::RuboCop::Cop::Base
  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/new_thread.rb#18
  def new_thread?(param0 = T.unsafe(nil)); end

  # source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/new_thread.rb#22
  def on_send(node); end
end

# source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/new_thread.rb#14
RuboCop::Cop::ThreadSafety::NewThread::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-thread_safety//lib/rubocop/cop/thread_safety/new_thread.rb#15
RuboCop::Cop::ThreadSafety::NewThread::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# RuboCop::ThreadSafety detects some potential thread safety issues.
#
# source://rubocop-thread_safety//lib/rubocop/thread_safety.rb#5
module RuboCop::ThreadSafety; end

# source://rubocop-thread_safety//lib/rubocop/thread_safety.rb#8
RuboCop::ThreadSafety::CONFIG = T.let(T.unsafe(nil), Hash)

# source://rubocop-thread_safety//lib/rubocop/thread_safety.rb#7
RuboCop::ThreadSafety::CONFIG_DEFAULT = T.let(T.unsafe(nil), Pathname)

# Because RuboCop doesn't yet support plugins, we have to monkey patch in a
# bit of our configuration.
#
# source://rubocop-thread_safety//lib/rubocop/thread_safety/inject.rb#9
module RuboCop::ThreadSafety::Inject
  class << self
    # source://rubocop-thread_safety//lib/rubocop/thread_safety/inject.rb#10
    def defaults!; end
  end
end

# source://rubocop-thread_safety//lib/rubocop/thread_safety.rb#6
RuboCop::ThreadSafety::PROJECT_ROOT = T.let(T.unsafe(nil), Pathname)

# source://rubocop-thread_safety//lib/rubocop/thread_safety/version.rb#5
RuboCop::ThreadSafety::VERSION = T.let(T.unsafe(nil), String)
