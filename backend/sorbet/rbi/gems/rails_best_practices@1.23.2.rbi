# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rails_best_practices` gem.
# Please instead update this file by running `bin/tapioca gem rails_best_practices`.

# source://rails_best_practices//lib/rails_best_practices/core_ext/erubis.rb#5
module Erubis; end

# source://rails_best_practices//lib/rails_best_practices/core_ext/erubis.rb#6
class Erubis::OnlyRuby < ::Erubis::Eruby
  # source://rails_best_practices//lib/rails_best_practices/core_ext/erubis.rb#28
  def add_expr_debug(src, code); end

  # source://rails_best_practices//lib/rails_best_practices/core_ext/erubis.rb#23
  def add_expr_escaped(src, code); end

  # source://rails_best_practices//lib/rails_best_practices/core_ext/erubis.rb#18
  def add_expr_literal(src, code); end

  # source://rails_best_practices//lib/rails_best_practices/core_ext/erubis.rb#33
  def add_postamble(src); end

  # source://rails_best_practices//lib/rails_best_practices/core_ext/erubis.rb#7
  def add_preamble(src); end

  # source://rails_best_practices//lib/rails_best_practices/core_ext/erubis.rb#13
  def add_stmt(src, code); end

  # source://rails_best_practices//lib/rails_best_practices/core_ext/erubis.rb#9
  def add_text(src, text); end
end

# source://rails_best_practices//lib/rails_best_practices/core/check.rb#3
module RailsBestPractices; end

# RailsBestPractices Analyzer helps you to analyze your rails code, according to best practices on https://rails-bestpractices.
# if it finds any violatioins to best practices, it will give you some readable suggestions.
#
# The analysis process is partitioned into two parts,
#
# 1. prepare process, it checks only model and mailer files, do some preparations, such as remember model names and associations.
# 2. review process, it checks all files, according to configuration, it really check if codes violate the best practices, if so, remember the violations.
#
# After analyzing, output the violations.
#
# source://rails_best_practices//lib/rails_best_practices/analyzer.rb#17
class RailsBestPractices::Analyzer
  # initialize
  #
  # @param path [String] where to generate the configuration yaml file
  # @param options [Hash]
  # @return [Analyzer] a new instance of Analyzer
  #
  # source://rails_best_practices//lib/rails_best_practices/analyzer.rb#28
  def initialize(path, options = T.unsafe(nil)); end

  # Analyze rails codes.
  #
  # there are two steps to check rails codes,
  #
  # 1. prepare process, check all model and mailer files.
  # 2. review process, check all files.
  #
  # if there are violations to rails best practices, output them.
  #
  # @param path [String] the directory of rails project
  # @param options [Hash]
  #
  # source://rails_best_practices//lib/rails_best_practices/analyzer.rb#52
  def analyze; end

  # analyze source codes.
  #
  # source://rails_best_practices//lib/rails_best_practices/analyzer.rb#329
  def analyze_source_codes; end

  # analyze version control system info.
  #
  # source://rails_best_practices//lib/rails_best_practices/analyzer.rb#336
  def analyze_vcs; end

  # if disaply progress bar.
  #
  # @return [Boolean]
  #
  # source://rails_best_practices//lib/rails_best_practices/analyzer.rb#342
  def display_bar?; end

  # unique error types.
  #
  # source://rails_best_practices//lib/rails_best_practices/analyzer.rb#347
  def error_types; end

  # delegate errors to runner
  #
  # source://rails_best_practices//lib/rails_best_practices/analyzer.rb#352
  def errors; end

  # expand all files with extenstion rb, erb, haml, slim, builder and rxml under the dirs
  #
  # @param dirs [Array] what directories to expand
  # @return [Array] all files expanded
  #
  # source://rails_best_practices//lib/rails_best_practices/analyzer.rb#138
  def expand_dirs_to_files(*dirs); end

  # accept specific files.
  #
  # @param files [Array]
  # @param patterns, [Regexp] files match any pattern will be accepted
  #
  # source://rails_best_practices//lib/rails_best_practices/analyzer.rb#182
  def file_accept(files, patterns); end

  # ignore specific files.
  #
  # @param files [Array]
  # @param pattern [Regexp] files match the pattern will be ignored
  # @return [Array] files that not match the pattern
  #
  # source://rails_best_practices//lib/rails_best_practices/analyzer.rb#174
  def file_ignore(files, pattern); end

  # sort files, models first, mailers, helpers, and then sort other files by characters.
  #
  # models and mailers first as for prepare process.
  #
  # @param files [Array]
  # @return [Array] sorted files
  #
  # source://rails_best_practices//lib/rails_best_practices/analyzer.rb#158
  def file_sort(files); end

  # generate configuration yaml file.
  #
  # source://rails_best_practices//lib/rails_best_practices/analyzer.rb#37
  def generate; end

  # load git commit and git username info.
  #
  # source://rails_best_practices//lib/rails_best_practices/analyzer.rb#216
  def load_git_info; end

  # load hg commit and hg username info.
  #
  # source://rails_best_practices//lib/rails_best_practices/analyzer.rb#198
  def load_hg_info; end

  # Output the analyze result.
  #
  # source://rails_best_practices//lib/rails_best_practices/analyzer.rb#62
  def output; end

  # output errors with html format.
  #
  # source://rails_best_practices//lib/rails_best_practices/analyzer.rb#234
  def output_html_errors; end

  # output errors with json format.
  #
  # source://rails_best_practices//lib/rails_best_practices/analyzer.rb#305
  def output_json_errors; end

  # output errors on terminal.
  #
  # source://rails_best_practices//lib/rails_best_practices/analyzer.rb#187
  def output_terminal_errors; end

  # source://rails_best_practices//lib/rails_best_practices/analyzer.rb#266
  def output_xml_errors; end

  # output errors with yaml format.
  #
  # source://rails_best_practices//lib/rails_best_practices/analyzer.rb#298
  def output_yaml_errors; end

  # get all files for parsing.
  #
  # @return [Array] all files for parsing
  #
  # source://rails_best_practices//lib/rails_best_practices/analyzer.rb#106
  def parse_files; end

  # Returns the value of attribute path.
  #
  # source://rails_best_practices//lib/rails_best_practices/analyzer.rb#19
  def path; end

  # plain output with color.
  #
  # @param message [String] to output
  # @param color [String]
  #
  # source://rails_best_practices//lib/rails_best_practices/analyzer.rb#320
  def plain_output(message, color); end

  # process lexical, prepare or reivew.
  #
  # get all files for the process, analyze each file,
  # and increment progress bar unless debug.
  #
  # @param process [String] the process name, lexical, prepare or review.
  #
  # source://rails_best_practices//lib/rails_best_practices/analyzer.rb#87
  def process(process); end

  # Returns the value of attribute runner.
  #
  # source://rails_best_practices//lib/rails_best_practices/analyzer.rb#18
  def runner; end

  # Sets the attribute runner
  #
  # @param value the value to set the attribute runner to.
  #
  # source://rails_best_practices//lib/rails_best_practices/analyzer.rb#18
  def runner=(_arg0); end
end

# source://rails_best_practices//lib/rails_best_practices/analyzer.rb#21
RailsBestPractices::Analyzer::DEFAULT_CONFIG = T.let(T.unsafe(nil), String)

# source://rails_best_practices//lib/rails_best_practices/analyzer.rb#22
RailsBestPractices::Analyzer::GITHUB_URL = T.let(T.unsafe(nil), String)

# source://rails_best_practices//lib/rails_best_practices/cli.rb#4
class RailsBestPractices::CLI
  class << self
    # Run analyze with ruby code
    #
    # @example
    #   RailsBestPractices::CLI.run(['-d', '-o', 'path/to/file'])
    # @param argv [Array] command argments
    # @return [Boolean] return true, if there is no violation.
    #
    # source://rails_best_practices//lib/rails_best_practices/cli.rb#10
    def run(argv); end
  end
end

# source://rails_best_practices//lib/rails_best_practices/colorize.rb#4
class RailsBestPractices::Colorize
  class << self
    # source://rails_best_practices//lib/rails_best_practices/colorize.rb#9
    def green(message); end

    # source://rails_best_practices//lib/rails_best_practices/colorize.rb#5
    def red(message); end
  end
end

# source://rails_best_practices//lib/rails_best_practices/core/check.rb#4
module RailsBestPractices::Core; end

# A Check class that takes charge of checking the sexp.
#
# source://rails_best_practices//lib/rails_best_practices/core/check.rb#7
class RailsBestPractices::Core::Check < ::CodeAnalyzer::Checker
  # @return [Check] a new instance of Check
  #
  # source://rails_best_practices//lib/rails_best_practices/core/check.rb#26
  def initialize(options = T.unsafe(nil)); end

  # add error if source code violates rails best practice.
  #
  # @param message, [String] is the string message for violation of the rails best practice
  # @param filename, [String] is the filename of source code
  # @param line_number, [Integer] is the line number of the source code which is reviewing
  #
  # source://rails_best_practices//lib/rails_best_practices/core/check.rb#63
  def add_error(message, filename = T.unsafe(nil), line_number = T.unsafe(nil)); end

  # errors that violate the rails best practices.
  #
  # source://rails_best_practices//lib/rails_best_practices/core/check.rb#71
  def errors; end

  # @return [Boolean]
  #
  # source://rails_best_practices//lib/rails_best_practices/core/check.rb#50
  def is_ignored?(node_file); end

  # @return [Boolean]
  #
  # source://rails_best_practices//lib/rails_best_practices/core/check.rb#40
  def is_interesting_file?(node_file); end

  # method_missing to catch all start and end process for each node type, like
  #
  #     start_def
  #     end_def
  #     start_call
  #     end_call
  #
  # if there is a "debug" method defined in check, each node will be output.
  #
  # source://rails_best_practices//lib/rails_best_practices/core/check.rb#90
  def method_missing(method_name, *args); end

  # check if the check will need to parse the node file.
  #
  # @param the [String] file name of node.
  # @return [Boolean] true if the check will need to parse the file.
  #
  # source://rails_best_practices//lib/rails_best_practices/core/check.rb#36
  def parse_file?(node_file); end

  # source://rails_best_practices//lib/rails_best_practices/core/check.rb#54
  def regex_ignored_files; end

  # default url is empty.
  #
  # @return [String] the url of rails best practice
  #
  # source://rails_best_practices//lib/rails_best_practices/core/check.rb#78
  def url; end

  class << self
    # source://rails_best_practices//lib/rails_best_practices/core/check.rb#109
    def debug; end

    # @return [Boolean]
    #
    # source://rails_best_practices//lib/rails_best_practices/core/check.rb#105
    def debug?; end

    # source://rails_best_practices//lib/rails_best_practices/core/check.rb#101
    def url(url = T.unsafe(nil)); end
  end
end

# source://rails_best_practices//lib/rails_best_practices/core/check.rb#8
RailsBestPractices::Core::Check::ALL_FILES = T.let(T.unsafe(nil), Regexp)

# Helper to parse the access control.
#
# source://rails_best_practices//lib/rails_best_practices/core/check.rb#400
module RailsBestPractices::Core::Check::Accessable
  # get the current acces control.
  #
  # source://rails_best_practices//lib/rails_best_practices/core/check.rb#431
  def current_access_control; end

  class << self
    # @private
    #
    # source://rails_best_practices//lib/rails_best_practices/core/check.rb#401
    def included(base); end
  end
end

# source://rails_best_practices//lib/rails_best_practices/core/check.rb#21
RailsBestPractices::Core::Check::CAPFILE = T.let(T.unsafe(nil), Regexp)

# source://rails_best_practices//lib/rails_best_practices/core/check.rb#19
RailsBestPractices::Core::Check::CONFIG_FILES = T.let(T.unsafe(nil), Regexp)

# source://rails_best_practices//lib/rails_best_practices/core/check.rb#9
RailsBestPractices::Core::Check::CONTROLLER_FILES = T.let(T.unsafe(nil), Regexp)

# Helper to add callbacks to mark the methods are used.
#
# source://rails_best_practices//lib/rails_best_practices/core/check.rb#197
module RailsBestPractices::Core::Check::Callable
  class << self
    # @private
    #
    # source://rails_best_practices//lib/rails_best_practices/core/check.rb#198
    def included(base); end
  end
end

# Helper to parse the class name.
#
# source://rails_best_practices//lib/rails_best_practices/core/check.rb#116
module RailsBestPractices::Core::Check::Classable
  # modules.
  #
  # source://rails_best_practices//lib/rails_best_practices/core/check.rb#157
  def classable_modules; end

  # get the current class name.
  #
  # source://rails_best_practices//lib/rails_best_practices/core/check.rb#147
  def current_class_name; end

  # get the current extend class name.
  #
  # source://rails_best_practices//lib/rails_best_practices/core/check.rb#152
  def current_extend_class_name; end

  # source://rails_best_practices//lib/rails_best_practices/core/check.rb#161
  def klasses; end

  class << self
    # @private
    #
    # source://rails_best_practices//lib/rails_best_practices/core/check.rb#117
    def included(base); end
  end
end

# source://rails_best_practices//lib/rails_best_practices/core/check.rb#18
RailsBestPractices::Core::Check::DEPLOY_FILES = T.let(T.unsafe(nil), Regexp)

# Helper to check except methods.
#
# source://rails_best_practices//lib/rails_best_practices/core/check.rb#357
module RailsBestPractices::Core::Check::Exceptable
  class << self
    # @private
    #
    # source://rails_best_practices//lib/rails_best_practices/core/check.rb#358
    def included(base); end

    # source://rails_best_practices//lib/rails_best_practices/core/check.rb#376
    def matches(method, except_method); end
  end
end

# source://rails_best_practices//lib/rails_best_practices/core/check.rb#22
RailsBestPractices::Core::Check::GEMFILE_LOCK = T.let(T.unsafe(nil), Regexp)

# source://rails_best_practices//lib/rails_best_practices/core/check.rb#17
RailsBestPractices::Core::Check::HELPER_FILES = T.let(T.unsafe(nil), Regexp)

# source://rails_best_practices//lib/rails_best_practices/core/check.rb#20
RailsBestPractices::Core::Check::INITIALIZER_FILES = T.let(T.unsafe(nil), Regexp)

# Helper to indicate if the controller is inherited from InheritedResources.
#
# source://rails_best_practices//lib/rails_best_practices/core/check.rb#326
module RailsBestPractices::Core::Check::InheritedResourcesable
  class << self
    # @private
    #
    # source://rails_best_practices//lib/rails_best_practices/core/check.rb#327
    def included(base); end
  end
end

# source://rails_best_practices//lib/rails_best_practices/core/check.rb#12
RailsBestPractices::Core::Check::MAILER_FILES = T.let(T.unsafe(nil), Regexp)

# source://rails_best_practices//lib/rails_best_practices/core/check.rb#10
RailsBestPractices::Core::Check::MIGRATION_FILES = T.let(T.unsafe(nil), Regexp)

# source://rails_best_practices//lib/rails_best_practices/core/check.rb#11
RailsBestPractices::Core::Check::MODEL_FILES = T.let(T.unsafe(nil), Regexp)

# Helper to parse the module name.
#
# source://rails_best_practices//lib/rails_best_practices/core/check.rb#168
module RailsBestPractices::Core::Check::Moduleable
  # get the current module name.
  #
  # source://rails_best_practices//lib/rails_best_practices/core/check.rb#186
  def current_module_name; end

  # modules.
  #
  # source://rails_best_practices//lib/rails_best_practices/core/check.rb#191
  def moduleable_modules; end

  class << self
    # @private
    #
    # source://rails_best_practices//lib/rails_best_practices/core/check.rb#169
    def included(base); end
  end
end

# source://rails_best_practices//lib/rails_best_practices/core/check.rb#14
RailsBestPractices::Core::Check::PARTIAL_VIEW_FILES = T.let(T.unsafe(nil), Regexp)

# source://rails_best_practices//lib/rails_best_practices/core/check.rb#15
RailsBestPractices::Core::Check::ROUTE_FILES = T.let(T.unsafe(nil), Regexp)

# source://rails_best_practices//lib/rails_best_practices/core/check.rb#16
RailsBestPractices::Core::Check::SCHEMA_FILE = T.let(T.unsafe(nil), Regexp)

# source://rails_best_practices//lib/rails_best_practices/core/check.rb#24
RailsBestPractices::Core::Check::SKIP_FILES = T.let(T.unsafe(nil), Regexp)

# source://rails_best_practices//lib/rails_best_practices/core/check.rb#13
RailsBestPractices::Core::Check::VIEW_FILES = T.let(T.unsafe(nil), Regexp)

# source://rails_best_practices//lib/rails_best_practices/core/checks_loader.rb#5
class RailsBestPractices::Core::ChecksLoader
  # @return [ChecksLoader] a new instance of ChecksLoader
  #
  # source://rails_best_practices//lib/rails_best_practices/core/checks_loader.rb#6
  def initialize(config); end

  # load all lexical checks.
  #
  # source://rails_best_practices//lib/rails_best_practices/core/checks_loader.rb#11
  def load_lexicals; end

  # load all reviews according to configuration.
  #
  # source://rails_best_practices//lib/rails_best_practices/core/checks_loader.rb#16
  def load_reviews; end

  private

  # read the checks from yaml config.
  #
  # source://rails_best_practices//lib/rails_best_practices/core/checks_loader.rb#25
  def checks_from_config; end

  # instantiates a check
  #
  # source://rails_best_practices//lib/rails_best_practices/core/checks_loader.rb#38
  def instantiate_check(block, check_name, options); end

  # loads the class for a check by calling the given block
  #
  # source://rails_best_practices//lib/rails_best_practices/core/checks_loader.rb#44
  def load_check_class(check_name); end

  # load all checks from the configuration
  #
  # source://rails_best_practices//lib/rails_best_practices/core/checks_loader.rb#30
  def load_checks_from_config(&block); end
end

# source://rails_best_practices//lib/rails_best_practices/core/configs.rb#5
class RailsBestPractices::Core::Configs < ::Hash; end

# Controller classes.
#
# source://rails_best_practices//lib/rails_best_practices/core/controllers.rb#8
class RailsBestPractices::Core::Controllers < ::RailsBestPractices::Core::Klasses; end

# Error is the violation to rails best practice.
#
# it indicates the filenname, line number and error message for the violation.
#
# source://rails_best_practices//lib/rails_best_practices/core/error.rb#8
class RailsBestPractices::Core::Error < ::CodeAnalyzer::Warning
  # @return [Error] a new instance of Error
  #
  # source://rails_best_practices//lib/rails_best_practices/core/error.rb#12
  def initialize(options = T.unsafe(nil)); end

  # source://rails_best_practices//lib/rails_best_practices/core/error.rb#26
  def first_line_number; end

  # Returns the value of attribute git_commit.
  #
  # source://rails_best_practices//lib/rails_best_practices/core/error.rb#10
  def git_commit; end

  # Sets the attribute git_commit
  #
  # @param value the value to set the attribute git_commit to.
  #
  # source://rails_best_practices//lib/rails_best_practices/core/error.rb#10
  def git_commit=(_arg0); end

  # Returns the value of attribute git_username.
  #
  # source://rails_best_practices//lib/rails_best_practices/core/error.rb#10
  def git_username; end

  # Sets the attribute git_username
  #
  # @param value the value to set the attribute git_username to.
  #
  # source://rails_best_practices//lib/rails_best_practices/core/error.rb#10
  def git_username=(_arg0); end

  # Returns the value of attribute hg_commit.
  #
  # source://rails_best_practices//lib/rails_best_practices/core/error.rb#10
  def hg_commit; end

  # Sets the attribute hg_commit
  #
  # @param value the value to set the attribute hg_commit to.
  #
  # source://rails_best_practices//lib/rails_best_practices/core/error.rb#10
  def hg_commit=(_arg0); end

  # Returns the value of attribute hg_username.
  #
  # source://rails_best_practices//lib/rails_best_practices/core/error.rb#10
  def hg_username; end

  # Sets the attribute hg_username
  #
  # @param value the value to set the attribute hg_username to.
  #
  # source://rails_best_practices//lib/rails_best_practices/core/error.rb#10
  def hg_username=(_arg0); end

  # source://rails_best_practices//lib/rails_best_practices/core/error.rb#22
  def short_filename; end

  # Returns the value of attribute type.
  #
  # source://rails_best_practices//lib/rails_best_practices/core/error.rb#9
  def type; end

  # Returns the value of attribute url.
  #
  # source://rails_best_practices//lib/rails_best_practices/core/error.rb#9
  def url; end
end

# Gem info includes gem name and gem version
#
# source://rails_best_practices//lib/rails_best_practices/core/gems.rb#16
class RailsBestPractices::Core::Gem
  # @return [Gem] a new instance of Gem
  #
  # source://rails_best_practices//lib/rails_best_practices/core/gems.rb#19
  def initialize(name, version); end

  # Returns the value of attribute name.
  #
  # source://rails_best_practices//lib/rails_best_practices/core/gems.rb#17
  def name; end

  # source://rails_best_practices//lib/rails_best_practices/core/gems.rb#24
  def to_s; end

  # Returns the value of attribute version.
  #
  # source://rails_best_practices//lib/rails_best_practices/core/gems.rb#17
  def version; end
end

# source://rails_best_practices//lib/rails_best_practices/core/gems.rb#5
class RailsBestPractices::Core::Gems < ::Array
  # source://rails_best_practices//lib/rails_best_practices/core/gems.rb#10
  def gem_version(gem_name); end

  # @return [Boolean]
  #
  # source://rails_best_practices//lib/rails_best_practices/core/gems.rb#6
  def has_gem?(gem_name); end
end

# Helper moduels.
#
# source://rails_best_practices//lib/rails_best_practices/core/helpers.rb#8
class RailsBestPractices::Core::Helpers < ::RailsBestPractices::Core::Modules; end

# Class info includes class name, extend class name and module names.
#
# source://rails_best_practices//lib/rails_best_practices/core/klasses.rb#17
class RailsBestPractices::Core::Klass
  # @return [Klass] a new instance of Klass
  #
  # source://rails_best_practices//lib/rails_best_practices/core/klasses.rb#20
  def initialize(class_name, extend_class_name, modules); end

  # Returns the value of attribute class_name.
  #
  # source://rails_best_practices//lib/rails_best_practices/core/klasses.rb#18
  def class_name; end

  # Returns the value of attribute extend_class_name.
  #
  # source://rails_best_practices//lib/rails_best_practices/core/klasses.rb#18
  def extend_class_name; end

  # source://rails_best_practices//lib/rails_best_practices/core/klasses.rb#29
  def to_s; end
end

# Klass container.
#
# source://rails_best_practices//lib/rails_best_practices/core/klasses.rb#6
class RailsBestPractices::Core::Klasses < ::Array
  # If include the class.
  #
  # @param class [String] name
  # @return [Boolean] include or not
  #
  # source://rails_best_practices//lib/rails_best_practices/core/klasses.rb#11
  def include?(class_name); end
end

# Mailer classes.
#
# source://rails_best_practices//lib/rails_best_practices/core/mailers.rb#6
class RailsBestPractices::Core::Mailers < ::RailsBestPractices::Core::Klasses; end

# Method info includes class name, method name, access control, file, line_number, used.
#
# source://rails_best_practices//lib/rails_best_practices/core/methods.rb#153
class RailsBestPractices::Core::Method
  # @return [Method] a new instance of Method
  #
  # source://rails_best_practices//lib/rails_best_practices/core/methods.rb#156
  def initialize(class_name, method_name, access_control, meta); end

  # Returns the value of attribute access_control.
  #
  # source://rails_best_practices//lib/rails_best_practices/core/methods.rb#154
  def access_control; end

  # Returns the value of attribute class_name.
  #
  # source://rails_best_practices//lib/rails_best_practices/core/methods.rb#154
  def class_name; end

  # Returns the value of attribute file.
  #
  # source://rails_best_practices//lib/rails_best_practices/core/methods.rb#154
  def file; end

  # Returns the value of attribute line_number.
  #
  # source://rails_best_practices//lib/rails_best_practices/core/methods.rb#154
  def line_number; end

  # Mark the method as used.
  #
  # source://rails_best_practices//lib/rails_best_practices/core/methods.rb#166
  def mark_used; end

  # Returns the value of attribute method_name.
  #
  # source://rails_best_practices//lib/rails_best_practices/core/methods.rb#154
  def method_name; end

  # Mark the method as public
  #
  # source://rails_best_practices//lib/rails_best_practices/core/methods.rb#171
  def publicize; end

  # Returns the value of attribute used.
  #
  # source://rails_best_practices//lib/rails_best_practices/core/methods.rb#154
  def used; end
end

# Method container.
#
# source://rails_best_practices//lib/rails_best_practices/core/methods.rb#6
class RailsBestPractices::Core::Methods
  # @return [Methods] a new instance of Methods
  #
  # source://rails_best_practices//lib/rails_best_practices/core/methods.rb#7
  def initialize; end

  # Add a method.
  #
  # @param class [String] name
  # @param method [String] name
  # @param method [Hash] meta, file and line, {"file" => "app/models/post.rb", "line_number" => 5}
  # @param access [String] control, public, protected or private
  #
  # source://rails_best_practices//lib/rails_best_practices/core/methods.rb#18
  def add_method(class_name, method_name, meta = T.unsafe(nil), access_control = T.unsafe(nil)); end

  # Get all unused methods.
  #
  # @param access [String] control
  # @return [Array] array of Method
  #
  # source://rails_best_practices//lib/rails_best_practices/core/methods.rb#130
  def get_all_unused_methods(access_control = T.unsafe(nil)); end

  # Get a method in a class.
  #
  # @param class [String] name
  # @param method [String] name
  # @param access [String] control
  # @return [Method] Method object
  #
  # source://rails_best_practices//lib/rails_best_practices/core/methods.rb#116
  def get_method(class_name, method_name, access_control = T.unsafe(nil)); end

  # Get methods of a class.
  #
  # @param class [String] name
  # @param access [String] control
  # @return [Array] all methods of a class for such access control, if access control is nil, return all public/protected/private methods
  #
  # source://rails_best_practices//lib/rails_best_practices/core/methods.rb#33
  def get_methods(class_name, access_control = T.unsafe(nil)); end

  # If a class has a method.
  #
  # @param class [String] name
  # @param method [String] name
  # @param access [String] control
  # @return [Boolean] has a method or not
  #
  # source://rails_best_practices//lib/rails_best_practices/core/methods.rb#47
  def has_method?(class_name, method_name, access_control = T.unsafe(nil)); end

  # Mark parent class' method as used.
  #
  # @param class [String] name
  # @param method [String] name
  #
  # source://rails_best_practices//lib/rails_best_practices/core/methods.rb#61
  def mark_parent_class_method_used(class_name, method_name); end

  # Mark parent classs' method as public.
  #
  # @param class [String] name
  # @param method [String] name
  #
  # source://rails_best_practices//lib/rails_best_practices/core/methods.rb#95
  def mark_parent_class_methods_publicize(class_name, method_name); end

  # Mark the method as public.
  #
  # @param class [String] name
  # @param method [String] name
  #
  # source://rails_best_practices//lib/rails_best_practices/core/methods.rb#86
  def mark_publicize(class_name, method_name); end

  # Mark sub classes' method as used.
  #
  # @param class [String] name
  # @param method [String] name
  #
  # source://rails_best_practices//lib/rails_best_practices/core/methods.rb#74
  def mark_subclasses_method_used(class_name, method_name); end

  # Remomber the method name, the method is probably be used for the class' public method.
  #
  # @param method [String] name
  #
  # source://rails_best_practices//lib/rails_best_practices/core/methods.rb#106
  def possible_public_used(method_name); end

  private

  # Methods of a class.
  #
  # @param class [String] name
  # @return [Array] array of methods
  #
  # source://rails_best_practices//lib/rails_best_practices/core/methods.rb#147
  def methods(class_name); end
end

# Module info include module name and module spaces.
#
# source://rails_best_practices//lib/rails_best_practices/core/modules.rb#18
class RailsBestPractices::Core::Mod
  # @return [Mod] a new instance of Mod
  #
  # source://rails_best_practices//lib/rails_best_practices/core/modules.rb#21
  def initialize(module_name, modules); end

  # source://rails_best_practices//lib/rails_best_practices/core/modules.rb#27
  def add_descendant(descendant); end

  # Returns the value of attribute descendants.
  #
  # source://rails_best_practices//lib/rails_best_practices/core/modules.rb#19
  def descendants; end

  # source://rails_best_practices//lib/rails_best_practices/core/modules.rb#31
  def to_s; end
end

# Model associations container.
#
# source://rails_best_practices//lib/rails_best_practices/core/model_associations.rb#6
class RailsBestPractices::Core::ModelAssociations
  # @return [ModelAssociations] a new instance of ModelAssociations
  #
  # source://rails_best_practices//lib/rails_best_practices/core/model_associations.rb#7
  def initialize; end

  # @param model [String] name
  # @param association [String] name
  # @param association [String] meta, has_many, has_one, belongs_to and has_and_belongs_to_many
  # @param association [String] class name
  #
  # source://rails_best_practices//lib/rails_best_practices/core/model_associations.rb#16
  def add_association(model_name, association_name, association_meta, association_class = T.unsafe(nil)); end

  # delegate each to @associations.
  #
  # source://rails_best_practices//lib/rails_best_practices/core/model_associations.rb#44
  def each; end

  # Get a model association.
  #
  # @param model [String] name
  # @param association [String] name
  # @return [Hash] {"meta" => association_meta, "class_name" => association_class}
  #
  # source://rails_best_practices//lib/rails_best_practices/core/model_associations.rb#28
  def get_association(model_name, association_name); end

  # Get association's class name
  #
  # @param table [String] name
  # @param association_name [String]
  # @return [String] association's class name
  #
  # source://rails_best_practices//lib/rails_best_practices/core/model_associations.rb#53
  def get_association_class_name(table_name, association_name); end

  # If it is a model's association.
  #
  # @param model [String] name
  # @param association [String] name
  # @return [Boolean] true if it is the model's association
  #
  # source://rails_best_practices//lib/rails_best_practices/core/model_associations.rb#38
  def is_association?(model_name, association_name); end
end

# Model attributes container.
#
# source://rails_best_practices//lib/rails_best_practices/core/model_attributes.rb#6
class RailsBestPractices::Core::ModelAttributes
  # @return [ModelAttributes] a new instance of ModelAttributes
  #
  # source://rails_best_practices//lib/rails_best_practices/core/model_attributes.rb#7
  def initialize; end

  # Add a model attribute.
  #
  # @param model [String] name
  # @param attribute [String] name
  # @param attribute [String] type
  #
  # source://rails_best_practices//lib/rails_best_practices/core/model_attributes.rb#16
  def add_attribute(model_name, attribute_name, attribute_type); end

  # Get attribute type.
  #
  # @param model [String] name
  # @param attribute [String] name
  # @return [String] attribute type
  #
  # source://rails_best_practices//lib/rails_best_practices/core/model_attributes.rb#26
  def get_attribute_type(model_name, attribute_name); end

  # If it is a model's attribute.
  #
  # @param model [String] name
  # @param attribute [String] name
  # @return [Boolean] true if it is the model's attribute
  #
  # source://rails_best_practices//lib/rails_best_practices/core/model_attributes.rb#36
  def is_attribute?(model_name, attribute_name); end
end

# Model classes.
#
# source://rails_best_practices//lib/rails_best_practices/core/models.rb#6
class RailsBestPractices::Core::Models < ::RailsBestPractices::Core::Klasses; end

# Module container
#
# source://rails_best_practices//lib/rails_best_practices/core/modules.rb#6
class RailsBestPractices::Core::Modules < ::Array
  # add module descendant.
  #
  # @param module [String] name
  # @param descendant [String] name
  #
  # source://rails_best_practices//lib/rails_best_practices/core/modules.rb#11
  def add_module_descendant(module_name, descendant); end
end

# source://rails_best_practices//lib/rails_best_practices/core/routes.rb#18
class RailsBestPractices::Core::Route
  # @return [Route] a new instance of Route
  #
  # source://rails_best_practices//lib/rails_best_practices/core/routes.rb#21
  def initialize(namespaces, controller_name, action_name); end

  # Returns the value of attribute action_name.
  #
  # source://rails_best_practices//lib/rails_best_practices/core/routes.rb#19
  def action_name; end

  # Returns the value of attribute controller_name.
  #
  # source://rails_best_practices//lib/rails_best_practices/core/routes.rb#19
  def controller_name; end

  # source://rails_best_practices//lib/rails_best_practices/core/routes.rb#39
  def controller_name_with_namespaces; end

  # Returns the value of attribute namespaces.
  #
  # source://rails_best_practices//lib/rails_best_practices/core/routes.rb#19
  def namespaces; end

  # source://rails_best_practices//lib/rails_best_practices/core/routes.rb#47
  def to_s; end
end

# source://rails_best_practices//lib/rails_best_practices/core/routes.rb#5
class RailsBestPractices::Core::Routes < ::Array
  # add a route.
  #
  # @param namesapces [Array]
  # @param controller [String] name
  # @param action [String] name
  #
  # source://rails_best_practices//lib/rails_best_practices/core/routes.rb#11
  def add_route(namespaces, controller_name, action_name); end
end

# Runner is the main class, it can check source code of a filename with all checks (according to the configuration).
#
# the check process is partitioned into two parts,
#
# 1. prepare process, it will do some preparations for further checking, such as remember the model associations.
# 2. review process, it does real check, if the source code violates some best practices, the violations will be notified.
#
# source://rails_best_practices//lib/rails_best_practices/core/runner.rb#20
class RailsBestPractices::Core::Runner
  # initialize the runner.
  #
  # @param options [Hash] pass the prepares and reviews.
  # @return [Runner] a new instance of Runner
  #
  # source://rails_best_practices//lib/rails_best_practices/core/runner.rb#45
  def initialize(options = T.unsafe(nil)); end

  # source://rails_best_practices//lib/rails_best_practices/core/runner.rb#121
  def after_inline_disable; end

  # source://rails_best_practices//lib/rails_best_practices/core/runner.rb#81
  def after_lexical; end

  # source://rails_best_practices//lib/rails_best_practices/core/runner.rb#94
  def after_prepare; end

  # source://rails_best_practices//lib/rails_best_practices/core/runner.rb#108
  def after_review; end

  # Returns the value of attribute checks.
  #
  # source://rails_best_practices//lib/rails_best_practices/core/runner.rb#21
  def checks; end

  # get all errors from lexicals and reviews.
  #
  # @return [Array] all errors from lexicals and reviews
  #
  # source://rails_best_practices//lib/rails_best_practices/core/runner.rb#128
  def errors; end

  # disable check by inline comment the file.
  #
  # @param filename [String] of the file
  # @param content [String] of the file
  #
  # source://rails_best_practices//lib/rails_best_practices/core/runner.rb#116
  def inline_disable(filename, content); end

  # lexical analysis the file.
  #
  # @param filename [String] of the file
  # @param content [String] of the file
  #
  # source://rails_best_practices//lib/rails_best_practices/core/runner.rb#77
  def lexical(filename, content); end

  # prepare the file.
  #
  # @param filename [String] of the file
  # @param content [String] of the file
  #
  # source://rails_best_practices//lib/rails_best_practices/core/runner.rb#89
  def prepare(filename, content); end

  # review the file.
  #
  # @param filename [String] of the file
  # @param content [String] of the file
  #
  # source://rails_best_practices//lib/rails_best_practices/core/runner.rb#103
  def review(filename, content); end

  private

  # load all plugin reviews.
  #
  # source://rails_best_practices//lib/rails_best_practices/core/runner.rb#174
  def load_plugin_reviews; end

  # load all prepares.
  #
  # source://rails_best_practices//lib/rails_best_practices/core/runner.rb#169
  def load_prepares; end

  # parse html template code, erb, haml and slim.
  #
  # @param filename [String] is the filename of the erb, haml or slim code.
  # @param content [String] is the source code of erb, haml or slim file.
  #
  # source://rails_best_practices//lib/rails_best_practices/core/runner.rb#141
  def parse_html_template(filename, content); end

  class << self
    # get the base path, by default, the base path is current path.
    #
    # @return [String] the base path
    #
    # source://rails_best_practices//lib/rails_best_practices/core/runner.rb#29
    def base_path; end

    # Sets the attribute base_path
    #
    # @param value the value to set the attribute base_path to.
    #
    # source://rails_best_practices//lib/rails_best_practices/core/runner.rb#24
    def base_path=(_arg0); end

    # get the configuration path, if will default to config/rails_best_practices.yml
    #
    # @return [String] the config path
    #
    # source://rails_best_practices//lib/rails_best_practices/core/runner.rb#36
    def config_path; end

    # Sets the attribute config_path
    #
    # @param value the value to set the attribute config_path to.
    #
    # source://rails_best_practices//lib/rails_best_practices/core/runner.rb#24
    def config_path=(_arg0); end
  end
end

# source://rails_best_practices//lib/rails_best_practices/inline_disables/comment_ripper.rb#4
module RailsBestPractices::InlineDisables; end

# source://rails_best_practices//lib/rails_best_practices/inline_disables/comment_ripper.rb#5
class RailsBestPractices::InlineDisables::CommentRipper < ::Ripper::SexpBuilder
  # @return [CommentRipper] a new instance of CommentRipper
  #
  # source://rails_best_practices//lib/rails_best_practices/inline_disables/comment_ripper.rb#8
  def initialize(*arg); end

  # Returns the value of attribute comments.
  #
  # source://rails_best_practices//lib/rails_best_practices/inline_disables/comment_ripper.rb#6
  def comments; end

  # source://rails_best_practices//lib/rails_best_practices/inline_disables/comment_ripper.rb#13
  def on_comment(*arg); end
end

# source://rails_best_practices//lib/rails_best_practices/inline_disables/inline_disable.rb#5
class RailsBestPractices::InlineDisables::InlineDisable < ::RailsBestPractices::Core::Check
  # @return [InlineDisable] a new instance of InlineDisable
  #
  # source://rails_best_practices//lib/rails_best_practices/inline_disables/inline_disable.rb#9
  def initialize(*args); end

  # source://rails_best_practices//lib/rails_best_practices/inline_disables/inline_disable.rb#14
  def check(filename, content); end

  # @return [Boolean]
  #
  # source://rails_best_practices//lib/rails_best_practices/inline_disables/inline_disable.rb#21
  def disabled?(error); end

  private

  # source://rails_best_practices//lib/rails_best_practices/inline_disables/inline_disable.rb#42
  def add_as_disable_error(filename, check_name, line_number); end

  # source://rails_best_practices//lib/rails_best_practices/inline_disables/inline_disable.rb#32
  def add_as_disable_errors(filename, statement, line_number); end

  # source://rails_best_practices//lib/rails_best_practices/inline_disables/inline_disable.rb#28
  def disabled_error_keys; end
end

# source://rails_best_practices//lib/rails_best_practices/lexicals/long_line_check.rb#4
module RailsBestPractices::Lexicals; end

# Keep lines fewer than 80 characters.
#
# source://rails_best_practices//lib/rails_best_practices/lexicals/long_line_check.rb#6
class RailsBestPractices::Lexicals::LongLineCheck < ::RailsBestPractices::Core::Check
  # @return [LongLineCheck] a new instance of LongLineCheck
  #
  # source://rails_best_practices//lib/rails_best_practices/lexicals/long_line_check.rb#9
  def initialize(options = T.unsafe(nil)); end

  # check if a line is over 80 characters
  #
  # @param filename [String] name of the file
  # @param content [String] content of the file
  #
  # source://rails_best_practices//lib/rails_best_practices/lexicals/long_line_check.rb#18
  def check(filename, content); end
end

# Make sure there are no tabs in files.
#
# See the best practice details here https://rails-bestpractices.com/posts/2011/07/04/remove-tab/
#
# source://rails_best_practices//lib/rails_best_practices/lexicals/remove_tab_check.rb#8
class RailsBestPractices::Lexicals::RemoveTabCheck < ::RailsBestPractices::Core::Check
  # check if the content of file contains a tab.
  #
  # @param filename [String] name of the file
  # @param content [String] content of the file
  #
  # source://rails_best_practices//lib/rails_best_practices/lexicals/remove_tab_check.rb#16
  def check(filename, content); end
end

# Make sure there are no trailing whitespace in codes.
#
# See the best practice details here https://rails-bestpractices.com/posts/2010/12/02/remove-trailing-whitespace/
#
# source://rails_best_practices//lib/rails_best_practices/lexicals/remove_trailing_whitespace_check.rb#8
class RailsBestPractices::Lexicals::RemoveTrailingWhitespaceCheck < ::RailsBestPractices::Core::Check
  # check if the content of file contain a trailing whitespace.
  #
  # @param filename [String] name of the file
  # @param content [String] content of the file
  #
  # source://rails_best_practices//lib/rails_best_practices/lexicals/remove_trailing_whitespace_check.rb#16
  def check(filename, content); end
end

# source://rails_best_practices//lib/rails_best_practices/option_parser.rb#6
class RailsBestPractices::OptionParser
  class << self
    # Usage: rails_best_practices [options] path
    #    -d, --debug                      debug mode
    #        --silent                     silent mode
    #    -f, --format FORMAT              output format (text, html, yaml, json, xml)
    #        --output-file FILE           output html file for the analyzing result
    #        --without-color              only output plain text without color
    #        --with-atom                  open file by atom in html format
    #        --with-textmate              open file by textmate in html format
    #        --with-vscode                open file by vscode in html format
    #        --with-sublime               open file by sublime in html format (requires subl-handler)
    #        --with-mvim                  open file by mvim in html format
    #        --with-github GITHUB_NAME    open file on github in html format, GITHUB_NAME is like railsbp/rails-bestpractices.com
    #        --with-git                   display git commit and username, only support html format
    #        --with-hg                    display hg commit and username, only support html format
    #        --template TEMPLATE          customize erb template
    #        --vendor                     include vendor files
    #        --spec                       include spec files
    #        --test                       include test files
    #        --features                   include features files
    #    -x, --exclude PATTERNS           don't analyze files matching a pattern
    #                                     (comma-separated regexp list)
    #    -o, --only PATTERNS              analyze files only matching a pattern
    #                                     (comma-separated regexp list)
    #    -g, --generate                   generate configuration yaml
    #    -v, --version                    show this version
    #    -h, --help                       show this message
    #
    # source://rails_best_practices//lib/rails_best_practices/option_parser.rb#34
    def parse!(argv = T.unsafe(nil)); end
  end
end

# source://rails_best_practices//lib/rails_best_practices/prepares/config_prepare.rb#4
module RailsBestPractices::Prepares
  class << self
    # Clear all prepare objects.
    #
    # source://rails_best_practices//lib/rails_best_practices/prepares.rb#61
    def clear; end

    # source://rails_best_practices//lib/rails_best_practices/prepares.rb#52
    def configs; end

    # source://rails_best_practices//lib/rails_best_practices/prepares.rb#36
    def controller_methods; end

    # source://rails_best_practices//lib/rails_best_practices/prepares.rb#32
    def controllers; end

    # source://rails_best_practices//lib/rails_best_practices/prepares.rb#56
    def gems; end

    # source://rails_best_practices//lib/rails_best_practices/prepares.rb#44
    def helper_methods; end

    # source://rails_best_practices//lib/rails_best_practices/prepares.rb#40
    def helpers; end

    # source://rails_best_practices//lib/rails_best_practices/prepares.rb#8
    def klasses; end

    # source://rails_best_practices//lib/rails_best_practices/prepares.rb#28
    def mailers; end

    # source://rails_best_practices//lib/rails_best_practices/prepares.rb#16
    def model_associations; end

    # source://rails_best_practices//lib/rails_best_practices/prepares.rb#20
    def model_attributes; end

    # source://rails_best_practices//lib/rails_best_practices/prepares.rb#24
    def model_methods; end

    # source://rails_best_practices//lib/rails_best_practices/prepares.rb#12
    def models; end

    # source://rails_best_practices//lib/rails_best_practices/prepares.rb#48
    def routes; end
  end
end

# Remember all configs
#
# source://rails_best_practices//lib/rails_best_practices/prepares/config_prepare.rb#6
class RailsBestPractices::Prepares::ConfigPrepare < ::RailsBestPractices::Core::Check
  # @return [ConfigPrepare] a new instance of ConfigPrepare
  #
  # source://rails_best_practices//lib/rails_best_practices/prepares/config_prepare.rb#10
  def initialize; end
end

# Remember controllers and controller methods
#
# source://rails_best_practices//lib/rails_best_practices/prepares/controller_prepare.rb#7
class RailsBestPractices::Prepares::ControllerPrepare < ::RailsBestPractices::Core::Check
  include ::RailsBestPractices::Core::Check::Classable
  include ::RailsBestPractices::Core::Check::InheritedResourcesable
  include ::RailsBestPractices::Core::Check::Accessable

  # @return [ControllerPrepare] a new instance of ControllerPrepare
  #
  # source://rails_best_practices//lib/rails_best_practices/prepares/controller_prepare.rb#17
  def initialize; end
end

# source://rails_best_practices//lib/rails_best_practices/prepares/controller_prepare.rb#15
RailsBestPractices::Prepares::ControllerPrepare::DEFAULT_ACTIONS = T.let(T.unsafe(nil), Array)

# Remember all gems in Gemfile
#
# source://rails_best_practices//lib/rails_best_practices/prepares/gemfile_prepare.rb#6
class RailsBestPractices::Prepares::GemfilePrepare < ::RailsBestPractices::Core::Check
  # @return [GemfilePrepare] a new instance of GemfilePrepare
  #
  # source://rails_best_practices//lib/rails_best_practices/prepares/gemfile_prepare.rb#9
  def initialize; end

  # source://rails_best_practices//lib/rails_best_practices/prepares/gemfile_prepare.rb#13
  def check(_filename, content); end
end

# Remember helper methods.
#
# source://rails_best_practices//lib/rails_best_practices/prepares/helper_prepare.rb#6
class RailsBestPractices::Prepares::HelperPrepare < ::RailsBestPractices::Core::Check
  include ::RailsBestPractices::Core::Check::Moduleable
  include ::RailsBestPractices::Core::Check::Accessable

  # @return [HelperPrepare] a new instance of HelperPrepare
  #
  # source://rails_best_practices//lib/rails_best_practices/prepares/helper_prepare.rb#13
  def initialize; end
end

# Check all initializers
#
# source://rails_best_practices//lib/rails_best_practices/prepares/initializer_prepare.rb#7
class RailsBestPractices::Prepares::InitializerPrepare < ::RailsBestPractices::Core::Check
  # @return [InitializerPrepare] a new instance of InitializerPrepare
  #
  # source://rails_best_practices//lib/rails_best_practices/prepares/initializer_prepare.rb#11
  def initialize; end

  # check if the node is
  #     ActiveRecord::Base.send(:include, ActiveModel::ForbiddenAttributesProtection)
  #
  # @return [Boolean]
  #
  # source://rails_best_practices//lib/rails_best_practices/prepares/initializer_prepare.rb#24
  def include_forbidden_attributes_protection?(node); end
end

# Remember the mailer names.
#
# source://rails_best_practices//lib/rails_best_practices/prepares/mailer_prepare.rb#7
class RailsBestPractices::Prepares::MailerPrepare < ::RailsBestPractices::Core::Check
  include ::RailsBestPractices::Core::Check::Classable

  # @return [MailerPrepare] a new instance of MailerPrepare
  #
  # source://rails_best_practices//lib/rails_best_practices/prepares/mailer_prepare.rb#13
  def initialize; end
end

# Remember models and model associations.
#
# source://rails_best_practices//lib/rails_best_practices/prepares/model_prepare.rb#7
class RailsBestPractices::Prepares::ModelPrepare < ::RailsBestPractices::Core::Check
  include ::RailsBestPractices::Core::Check::Classable
  include ::RailsBestPractices::Core::Check::Accessable

  # @return [ModelPrepare] a new instance of ModelPrepare
  #
  # source://rails_best_practices//lib/rails_best_practices/prepares/model_prepare.rb#26
  def initialize; end

  private

  # remember associations, with class to association names.
  #
  # source://rails_best_practices//lib/rails_best_practices/prepares/model_prepare.rb#166
  def remember_association(node); end
end

# source://rails_best_practices//lib/rails_best_practices/prepares/model_prepare.rb#14
RailsBestPractices::Prepares::ModelPrepare::ASSOCIATION_METHODS = T.let(T.unsafe(nil), Array)

# Remembber routes.
#
# source://rails_best_practices//lib/rails_best_practices/prepares/route_prepare.rb#6
class RailsBestPractices::Prepares::RoutePrepare < ::RailsBestPractices::Core::Check
  # @return [RoutePrepare] a new instance of RoutePrepare
  #
  # source://rails_best_practices//lib/rails_best_practices/prepares/route_prepare.rb#13
  def initialize; end

  def add_customize_routes; end
  def add_resource_routes(node); end
  def add_resources_routes(node); end

  # source://rails_best_practices//lib/rails_best_practices/prepares/route_prepare.rb#258
  def current_controller_name; end

  # source://rails_best_practices//lib/rails_best_practices/prepares/route_prepare.rb#254
  def current_namespaces; end

  def get_resource_actions(action_names); end
  def get_resources_actions(action_names); end
end

# source://rails_best_practices//lib/rails_best_practices/prepares/route_prepare.rb#10
RailsBestPractices::Prepares::RoutePrepare::RESOURCES_ACTIONS = T.let(T.unsafe(nil), Array)

# source://rails_best_practices//lib/rails_best_practices/prepares/route_prepare.rb#11
RailsBestPractices::Prepares::RoutePrepare::RESOURCE_ACTIONS = T.let(T.unsafe(nil), Array)

# Remember the model attributes.
#
# source://rails_best_practices//lib/rails_best_practices/prepares/schema_prepare.rb#6
class RailsBestPractices::Prepares::SchemaPrepare < ::RailsBestPractices::Core::Check
  # @return [SchemaPrepare] a new instance of SchemaPrepare
  #
  # source://rails_best_practices//lib/rails_best_practices/prepares/schema_prepare.rb#13
  def initialize; end
end

# all attribute types
#
# source://rails_best_practices//lib/rails_best_practices/prepares/schema_prepare.rb#11
RailsBestPractices::Prepares::SchemaPrepare::ATTRIBUTE_TYPES = T.let(T.unsafe(nil), Array)

# source://rails_best_practices//lib/rails_best_practices/reviews/review.rb#4
module RailsBestPractices::Reviews; end

# Make sure to add a model virual attribute to simplify model creation.
#
# See the best practice details here https://rails-bestpractices.com/posts/2010/07/21/add-model-virtual-attribute/
#
# Implementation:
#
# Review process:
#   check method define nodes in all controller files,
#   if there are more than one [] method calls with the same receiver and arguments,
#   but assigned to one model's different attribute.
#   and after these method calls, there is a save method call for that model,
#   then the model needs to add a virtual attribute.
#
# source://rails_best_practices//lib/rails_best_practices/reviews/add_model_virtual_attribute_review.rb#19
class RailsBestPractices::Reviews::AddModelVirtualAttributeReview < ::RailsBestPractices::Reviews::Review
  private

  # check an attribute assignment node, if there is a array reference node in the right value of assignment node,
  # then remember this attribute assignment.
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/add_model_virtual_attribute_review.rb#51
  def assign(node); end

  # get the assignments of receiver.
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/add_model_virtual_attribute_review.rb#83
  def assignments(receiver); end

  # check a call node with message "save" or "save!",
  # if there exists an attribute assignment for the receiver of this call node,
  # and if the arguments of this attribute assignments has duplicated entries (different message and same arguments),
  # then this node needs to add a virtual attribute.
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/add_model_virtual_attribute_review.rb#66
  def call_assignment(node); end

  # Get the duplicate entries from an Enumerable.
  #
  # @return [Enumerable] the duplicate entries.
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/add_model_virtual_attribute_review.rb#90
  def dups(nodes); end

  # if the nodes are duplicated.
  #
  # @return [Boolean]
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/add_model_virtual_attribute_review.rb#76
  def params_dup?(nodes); end
end

# Review db/schema.rb file to make sure every reference key has a database index.
#
# See the best practice details here https://rails-bestpractices.com/posts/2010/07/24/always-add-db-index/
#
# Implementation:
#
# Review process:
#   only check the command and command_calls nodes and at the end of review process,
#   if the receiver of command node is "create_table", then remember the table names
#   if the receiver of command_call node is "integer" or "string" or "bigint" and suffix with _id, then remember it as foreign key
#   if the receiver of command_call node is "string", the name of it is _type suffixed and there is an integer or string column _id suffixed, then remember it as polymorphic foreign key
#   if the receiver of command_call node is remembered as foreign key and it have argument non-false "index", then remember the index columns
#   if the receiver of command node is "add_index", then remember the index columns
#   after all of these, at the end of review process
#
#       ActiveRecord::Schema.define(version: 20101201111111) do
#         ......
#       end
#
#   if there are any foreign keys not existed in index columns,
#   then the foreign keys should add db index.
#
# source://rails_best_practices//lib/rails_best_practices/reviews/always_add_db_index_review.rb#26
class RailsBestPractices::Reviews::AlwaysAddDbIndexReview < ::RailsBestPractices::Reviews::Review
  # @return [AlwaysAddDbIndexReview] a new instance of AlwaysAddDbIndexReview
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/always_add_db_index_review.rb#31
  def initialize(options = T.unsafe(nil)); end

  private

  # combine polymorphic foreign keys, e.g.
  #     [tagger_id], [tagger_type] => [tagger_id, tagger_type]
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/always_add_db_index_review.rb#170
  def combine_polymorphic_foreign_keys; end

  # check if more_array is greater than less_array or equal to less_array.
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/always_add_db_index_review.rb#192
  def greater_than_or_equal(more_array, less_array); end

  # check if the table's column is indexed.
  #
  # @return [Boolean]
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/always_add_db_index_review.rb#186
  def not_indexed?(table, column); end

  # remember foreign key columns
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/always_add_db_index_review.rb#118
  def remember_foreign_key_columns(node); end

  # remember the node as index columns, when used inside a table
  # block, i.e.
  #    t.index [:column_name, ...]
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/always_add_db_index_review.rb#103
  def remember_index_columns_inside_table(node); end

  # remember the node as index columns, when used outside a table
  # block, i.e.
  #   add_index :table_name, :column_name
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/always_add_db_index_review.rb#92
  def remember_index_columns_outside_table(node); end

  # remember table nodes
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/always_add_db_index_review.rb#112
  def remember_table_nodes(node); end

  # remove the non foreign keys with only _type column.
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/always_add_db_index_review.rb#162
  def remove_only_type_foreign_keys; end

  # remove the non foreign keys without corresponding tables.
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/always_add_db_index_review.rb#150
  def remove_table_not_exist_foreign_keys; end
end

# Review all code to make sure we either check the return value of "destroy"
# or use "destroy!"
#
# Review process:
#   Track which nodes are used by 'if', 'unless', '&&' nodes etc. as we pass them by.
#   Check all "save" calls to check the return value is used by a node we have visited.
#
# source://rails_best_practices//lib/rails_best_practices/reviews/check_destroy_return_value_review.rb#11
class RailsBestPractices::Reviews::CheckDestroyReturnValueReview < ::RailsBestPractices::Reviews::Review
  include ::RailsBestPractices::Core::Check::Classable

  # source://rails_best_practices//lib/rails_best_practices/reviews/check_destroy_return_value_review.rb#52
  def model_classnames; end

  # @return [Boolean]
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/check_destroy_return_value_review.rb#46
  def return_value_is_used?(node); end
end

# Review all code to make sure we either check the return value of "save", "update_attributes"
# and "create" or use "save!", "update_attributes!", or "create!", respectively.
#
# See the best practice details here https://rails-bestpractices.com/posts/2012/11/02/check-the-return-value-of-save-otherwise-use-save/
#
# Implementation:
#
# Review process:
#   Track which nodes are used by 'if', 'unless', '&&' nodes etc. as we pass them by.
#   Check all "save" calls to check the return value is used by a node we have visited.
#
# source://rails_best_practices//lib/rails_best_practices/reviews/check_save_return_value_review.rb#15
class RailsBestPractices::Reviews::CheckSaveReturnValueReview < ::RailsBestPractices::Reviews::Review
  include ::RailsBestPractices::Core::Check::Classable

  # source://rails_best_practices//lib/rails_best_practices/reviews/check_save_return_value_review.rb#57
  def model_classnames; end

  # @return [Boolean]
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/check_save_return_value_review.rb#51
  def return_value_is_used?(node); end
end

# Review model files to make sure not use default_scope
#
# See the best practice details here https://rails-bestpractices.com/posts/2013/06/15/default_scope-is-evil/
#
# Implementation:
#
# Review process:
#   check all command node to see if its message is default_scope
#
# source://rails_best_practices//lib/rails_best_practices/reviews/default_scope_is_evil_review.rb#13
class RailsBestPractices::Reviews::DefaultScopeIsEvilReview < ::RailsBestPractices::Reviews::Review; end

# Review config/deploy.rb file to make sure using the bundler's capistrano recipe.
#
# See the best practice details here https://rails-bestpractices.com/posts/2010/09/02/dry-bundler-in-capistrano/
#
# Implementation:
#
# Review process:
#   only check the command nodes to see if there is bundler namespace in config/deploy.rb file,
#
#   if the message of command node is "namespace" and the first argument  is "bundler",
#   then it should use bundler's capistrano recipe.
#
# source://rails_best_practices//lib/rails_best_practices/reviews/dry_bundler_in_capistrano_review.rb#16
class RailsBestPractices::Reviews::DryBundlerInCapistranoReview < ::RailsBestPractices::Reviews::Review; end

# Check ruby 1.8 style hash and suggest to change hash syntax to 1.9.
#
# Review process:
#   check hash nodes in all files,
#   if the sexp type of hash key nodes is not :@lable,
#   then the hash is ruby 1.8 style.
#
# source://rails_best_practices//lib/rails_best_practices/reviews/hash_syntax_review.rb#11
class RailsBestPractices::Reviews::HashSyntaxReview < ::RailsBestPractices::Reviews::Review
  protected

  # check if hash node is empty.
  #
  # @return [Boolean]
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/hash_syntax_review.rb#27
  def empty_hash?(node); end

  # check if hash key/value pairs are ruby 1.8 style.
  #
  # @return [Boolean]
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/hash_syntax_review.rb#32
  def hash_is_18?(node); end

  # check if the hash keys are valid to be converted to ruby 1.9
  # syntax.
  #
  # @return [Boolean]
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/hash_syntax_review.rb#41
  def valid_keys?(node); end
end

# source://rails_best_practices//lib/rails_best_practices/reviews/hash_syntax_review.rb#15
RailsBestPractices::Reviews::HashSyntaxReview::VALID_SYMBOL_KEY = T.let(T.unsafe(nil), Regexp)

# Make sure not to insert data in migration, move them to seed file.
#
# See the best practice details here https://rails-bestpractices.com/posts/2010/07/24/isolating-seed-data/
#
# Implementation:
#
# Review process:
#   1. check all assignment nodes,
#   if the right value is a call node with message "new",
#   then remember their left value as new variables.
#
#   2. check all call nodes,
#   if the message is "create" or "create!",
#   then it should be isolated to db seed.
#   if the message is "save" or "save!",
#   and the receiver is included in new variables,
#   then it should be isolated to db seed.
#
# source://rails_best_practices//lib/rails_best_practices/reviews/isolate_seed_data_review.rb#22
class RailsBestPractices::Reviews::IsolateSeedDataReview < ::RailsBestPractices::Reviews::Review
  # @return [IsolateSeedDataReview] a new instance of IsolateSeedDataReview
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/isolate_seed_data_review.rb#27
  def initialize(options = T.unsafe(nil)); end

  private

  # see if the receiver of the call node is included in the @new_varaibles.
  #
  # @return [Boolean]
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/isolate_seed_data_review.rb#69
  def new_record?(node); end

  # check assignment node,
  # if the right vavlue is a method_add_arg node with message "new",
  # then remember the left value as new variable.
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/isolate_seed_data_review.rb#61
  def remember_new_variable(node); end
end

# Review model files to make sure finders are on their own model.
#
# See the best practice details here https://rails-bestpractices.com/posts/2010/07/23/keep-finders-on-their-own-model/
#
# Implementation:
#
# Review process:
#   check all call nodes in model files.
#
#   if the call node is a finder (find, all, first or last),
#   and the it calls the other model,
#   and there is a hash argument for finder,
#   then it should keep finders on its own model.
#
# source://rails_best_practices//lib/rails_best_practices/reviews/keep_finders_on_their_own_model_review.rb#18
class RailsBestPractices::Reviews::KeepFindersOnTheirOwnModelReview < ::RailsBestPractices::Reviews::Review
  private

  # check if the call node is the finder of other model.
  #
  # the message of the node should be one of find, all, first or last,
  # and the receiver of the node should be with message :call (this is the other model),
  # and any of its arguments is a hash,
  # then it is the finder of other model.
  #
  # @return [Boolean]
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/keep_finders_on_their_own_model_review.rb#46
  def other_finder?(node); end
end

# source://rails_best_practices//lib/rails_best_practices/reviews/keep_finders_on_their_own_model_review.rb#23
RailsBestPractices::Reviews::KeepFindersOnTheirOwnModelReview::FINDERS = T.let(T.unsafe(nil), Array)

# Review to make sure not to avoid the law of demeter.
#
# See the best practice details here https://rails-bestpractices.com/posts/2010/07/24/the-law-of-demeter/
#
# Implementation:
#
# Review process:
#   check all method calls to see if there is method call to the association object.
#   if there is a call node whose receiver is an object of model (compare by name),
#   and whose message is an association of that model (also compare by name),
#   and outer the call node, it is also a call node,
#   then it violate the law of demeter.
#
# source://rails_best_practices//lib/rails_best_practices/reviews/law_of_demeter_review.rb#17
class RailsBestPractices::Reviews::LawOfDemeterReview < ::RailsBestPractices::Reviews::Review
  private

  # @return [Boolean]
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/law_of_demeter_review.rb#54
  def is_association_attribute?(association_class, association_name, attribute_name); end

  # check if the call node can use delegate to avoid violating law of demeter.
  #
  # if the receiver of receiver of the call node matchs any in model names,
  # and the message of receiver of the call node matchs any in association names,
  # then it needs delegate.
  #
  # @return [Boolean]
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/law_of_demeter_review.rb#43
  def need_delegate?(node); end
end

# source://rails_best_practices//lib/rails_best_practices/reviews/law_of_demeter_review.rb#22
RailsBestPractices::Reviews::LawOfDemeterReview::ASSOCIATION_METHODS = T.let(T.unsafe(nil), Array)

# Review a view file to make sure there is no finder, finder should be moved to controller.
#
# See the best practice details here https://rails-bestpractices.com/posts/2010/07/24/move-code-into-controller/
#
# Implementation:
#
# Review process:
#   only check all view files to see if there are finders, then the finders should be moved to controller.
#
# source://rails_best_practices//lib/rails_best_practices/reviews/move_code_into_controller_review.rb#13
class RailsBestPractices::Reviews::MoveCodeIntoControllerReview < ::RailsBestPractices::Reviews::Review
  private

  # check if the node is a finder call node.
  #
  # @return [Boolean]
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/move_code_into_controller_review.rb#41
  def finder?(node); end
end

# source://rails_best_practices//lib/rails_best_practices/reviews/move_code_into_controller_review.rb#18
RailsBestPractices::Reviews::MoveCodeIntoControllerReview::FINDERS = T.let(T.unsafe(nil), Array)

# Review a view file to make sure there is no complex options_for_select message call.
#
# See the best practice details here https://rails-bestpractices.com/posts/2010/07/24/move-code-into-helper/
#
# TODO: we need a better soluation, any suggestion?
#
# Implementation:
#
# Review process:
#   check al method method_add_arg nodes to see if there is a complex options_for_select helper.
#
#   if the message of the method_add_arg node is options_for_select,
#   and the first argument of the method_add_arg node is array,
#   and the size of the array is greater than array_count defined,
#   then the options_for_select method should be moved into helper.
#
# source://rails_best_practices//lib/rails_best_practices/reviews/move_code_into_helper_review.rb#20
class RailsBestPractices::Reviews::MoveCodeIntoHelperReview < ::RailsBestPractices::Reviews::Review
  # @return [MoveCodeIntoHelperReview] a new instance of MoveCodeIntoHelperReview
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/move_code_into_helper_review.rb#25
  def initialize(options = T.unsafe(nil)); end

  private

  # check if the arguments of options_for_select are complex.
  #
  # if the first argument is an array,
  # and the size of array is greater than @array_count you defined,
  # then it is complext.
  #
  # @return [Boolean]
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/move_code_into_helper_review.rb#46
  def complex_select_options?(node); end
end

# Review a view file to make sure there is no complex logic call for model.
#
# See the best practice details here https://rails-bestpractices.com/posts/2010/07/24/move-code-into-model/
#
# Implementation:
#
# Review process:
#   check if, unless, elsif there are multiple method calls or attribute assignments apply to one receiver,
#   and the receiver is a variable, then they should be moved into model.
#
# source://rails_best_practices//lib/rails_best_practices/reviews/move_code_into_model_review.rb#14
class RailsBestPractices::Reviews::MoveCodeIntoModelReview < ::RailsBestPractices::Reviews::Review
  # @return [MoveCodeIntoModelReview] a new instance of MoveCodeIntoModelReview
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/move_code_into_model_review.rb#19
  def initialize(options = T.unsafe(nil)); end
end

# Review a controller file to make sure there are no complex finder.
#
# See the best practice details here https://rails-bestpractices.com/posts/2010/07/14/move-finder-to-named_scope/
#
# Implementation:
#
# Review process:
#   check all method method_add_arg nodes in controller files.
#   if there is any call node with message find, all, first or last,
#   and it has a hash argument,
#   then it is a complex finder, and should be moved to model's named scope.
#
# source://rails_best_practices//lib/rails_best_practices/reviews/move_finder_to_named_scope_review.rb#16
class RailsBestPractices::Reviews::MoveFinderToNamedScopeReview < ::RailsBestPractices::Reviews::Review
  private

  # check if the method_add_arg node is a finder.
  #
  # if the receiver of method_add_arg node is a constant,
  # and the message of call method_add_arg is one of find, all, first or last,
  # and any of its arguments is a hash,
  # then it is a finder.
  #
  # @return [Boolean]
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/move_finder_to_named_scope_review.rb#38
  def finder?(node); end
end

# source://rails_best_practices//lib/rails_best_practices/reviews/move_finder_to_named_scope_review.rb#21
RailsBestPractices::Reviews::MoveFinderToNamedScopeReview::FINDERS = T.let(T.unsafe(nil), Array)

# Review a controller file to make sure that complex model logic should not exist in controller, should be moved into a model.
#
# See the best practice details here https://rails-bestpractices.com/posts/2010/07/21/move-model-logic-into-the-model/
#
# Implementation:
#
# Review process:
#   check all method defines in the controller files,
#   if there are multiple method calls apply to one receiver,
#   and the receiver is a variable,
#   then they are complex model logic, and they should be moved into model.
#
# source://rails_best_practices//lib/rails_best_practices/reviews/move_model_logic_into_model_review.rb#16
class RailsBestPractices::Reviews::MoveModelLogicIntoModelReview < ::RailsBestPractices::Reviews::Review
  # @return [MoveModelLogicIntoModelReview] a new instance of MoveModelLogicIntoModelReview
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/move_model_logic_into_model_review.rb#21
  def initialize(options = T.unsafe(nil)); end
end

# Review config/routes.rb file to make sure not to use too deep nesting routes.
#
# See the best practice details here https://rails-bestpractices.com/posts/2010/07/22/needless-deep-nesting/
#
# Implementation:
#
# Review process:
#   chech all method_add_block nodes in route file.
#
#   it is a recursively check in method_add_block node,
#
#   if it is a method_add_block node,
#   increment @counter at the beginning of resources,
#   decrement @counter at the end of resrouces,
#   recursively check nodes in block body.
#
#   if the child node is a command_call or command node,
#   and the message of the node is "resources" or "resource",
#   and the @counter is greater than @nested_count defined,
#   then it is a needless deep nesting.
#
# source://rails_best_practices//lib/rails_best_practices/reviews/needless_deep_nesting_review.rb#25
class RailsBestPractices::Reviews::NeedlessDeepNestingReview < ::RailsBestPractices::Reviews::Review
  # @return [NeedlessDeepNestingReview] a new instance of NeedlessDeepNestingReview
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/needless_deep_nesting_review.rb#30
  def initialize(options = T.unsafe(nil)); end

  private

  # check nested route.
  #
  # if the receiver of the method_add_block is with message "resources" or "resource",
  # then increment the @counter, recursively check the block body, and decrement the @counter.
  #
  # if the node type is command_call or command,
  # and its message is resources or resource,
  # then check if @counter is greater than or equal to @nested_count,
  # if so, it is the needless deep nesting.
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/needless_deep_nesting_review.rb#63
  def recursively_check(node); end
end

# Review all code to make sure we don't rescue Exception
# This is a common mistake by Java or C# devs in ruby.
#
# See the best practice details here https://rails-bestpractices.com/posts/2012/11/01/don-t-rescue-exception-rescue-standarderror/
#
# Implementation:
#
# Review process:
#   check all rescue node to see if its type is Exception
#
# source://rails_best_practices//lib/rails_best_practices/reviews/not_rescue_exception_review.rb#14
class RailsBestPractices::Reviews::NotRescueExceptionReview < ::RailsBestPractices::Reviews::Review; end

# Review config/routes file to make sure not use default route that rails generated.
#
# See the best practice details here https://rails-bestpractices.com/posts/2010/07/22/not-use-default-route-if-you-use-restful-design/
#
# Implementation:
#
# Review process:
#   check all method command_call or command node to see if it is the same as rails default route.
#
#     map.connect ':controller/:action/:id'
#     map.connect ':controller/:action/:id.:format'
#
#   or
#
#     match ':controller(/:action(/:id(.:format)))'
#
# source://rails_best_practices//lib/rails_best_practices/reviews/not_use_default_route_review.rb#20
class RailsBestPractices::Reviews::NotUseDefaultRouteReview < ::RailsBestPractices::Reviews::Review; end

# Review view and helper files to make sure not use time_ago_in_words or distance_of_time_in_words_to_now.
#
# See the best practice details here https://rails-bestpractices.com/posts/2012/02/10/not-use-time_ago_in_words/
#
# Implementation:
#
# Review process:
#   check all fcall node to see if its message is time_ago_in_words and distance_of_time_in_words_to_now
#
# source://rails_best_practices//lib/rails_best_practices/reviews/not_use_time_ago_in_words_review.rb#13
class RailsBestPractices::Reviews::NotUseTimeAgoInWordsReview < ::RailsBestPractices::Reviews::Review; end

# Review config/routes.rb file to make sure there are no overuse route customizations.
#
# See the best practice details here https://rails-bestpractices.com/posts/2010/07/22/overuse-route-customizations/
#
# Implementation:
#
# Review process:
#
#   check all method_add_block nodes in route file.
#   if the receiver of method_add_block node is with message resources,
#   and in the block body of method_add_block node, there are more than @customize_count command nodes,
#   whose message is get, post, update or delete,
#   then these custom routes are overuse.
#
# source://rails_best_practices//lib/rails_best_practices/reviews/overuse_route_customizations_review.rb#18
class RailsBestPractices::Reviews::OveruseRouteCustomizationsReview < ::RailsBestPractices::Reviews::Review
  # @return [OveruseRouteCustomizationsReview] a new instance of OveruseRouteCustomizationsReview
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/overuse_route_customizations_review.rb#25
  def initialize(options = T.unsafe(nil)); end

  private

  # check method_add_block node to calculate the count of member and collection custom routes.
  #
  # if its receiver is with message "resources",
  # then calculate the count of call nodes, whose message is get, post, update or delete,
  # it is just the count of member and collection custom routes.
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/overuse_route_customizations_review.rb#49
  def member_and_collection_count_for_rails3(node); end
end

# source://rails_best_practices//lib/rails_best_practices/reviews/overuse_route_customizations_review.rb#23
RailsBestPractices::Reviews::OveruseRouteCustomizationsReview::VERBS = T.let(T.unsafe(nil), Array)

# Review model files to make sure to use attr_accessible, attr_protected or strong_parameters to protect mass assignment.
#
# See the best practices details here https://rails-bestpractices.com/posts/2012/03/06/protect-mass-assignment/
#
# Implmentation:
#
# Review process:
#   check nodes to see if there is a command with message attr_accessible or attr_protected,
#   or include ActiveModel::ForbiddenAttributesProtection.
#
# source://rails_best_practices//lib/rails_best_practices/reviews/protect_mass_assignment_review.rb#15
class RailsBestPractices::Reviews::ProtectMassAssignmentReview < ::RailsBestPractices::Reviews::Review
  private

  # source://rails_best_practices//lib/rails_best_practices/reviews/protect_mass_assignment_review.rb#102
  def check_active_record(const_path_ref_node); end

  # source://rails_best_practices//lib/rails_best_practices/reviews/protect_mass_assignment_review.rb#58
  def check_activerecord_version; end

  # source://rails_best_practices//lib/rails_best_practices/reviews/protect_mass_assignment_review.rb#96
  def check_authlogic(node); end

  # source://rails_best_practices//lib/rails_best_practices/reviews/protect_mass_assignment_review.rb#90
  def check_devise(command_node); end

  # source://rails_best_practices//lib/rails_best_practices/reviews/protect_mass_assignment_review.rb#70
  def check_include_forbidden_attributes_protection_config; end

  # source://rails_best_practices//lib/rails_best_practices/reviews/protect_mass_assignment_review.rb#76
  def check_rails_builtin(node); end

  # source://rails_best_practices//lib/rails_best_practices/reviews/protect_mass_assignment_review.rb#83
  def check_strong_parameters(command_node); end

  # source://rails_best_practices//lib/rails_best_practices/reviews/protect_mass_assignment_review.rb#64
  def check_whitelist_attributes_config; end
end

# Review a helper file to make sure it is not an empty moduel.
#
# See the best practice details here https://rails-bestpractices.com/posts/2011/04/09/remove-empty-helpers/
#
# Implementation:
#
# Review process:
#   check all helper files, if the body of module is nil, then the helper file should be removed.
#
# source://rails_best_practices//lib/rails_best_practices/reviews/remove_empty_helpers_review.rb#13
class RailsBestPractices::Reviews::RemoveEmptyHelpersReview < ::RailsBestPractices::Reviews::Review
  protected

  # @return [Boolean]
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/remove_empty_helpers_review.rb#27
  def empty_body?(module_node); end
end

# Find out unused methods in controllers.
#
# Implementation:
#
# Review process:
#   remember all method calls in controllers,
#   if they are not defined in routes,
#   and they are not called in controllers,
#   then they are the unused methods in controllers.
#
# source://rails_best_practices//lib/rails_best_practices/reviews/remove_unused_methods_in_controllers_review.rb#15
class RailsBestPractices::Reviews::RemoveUnusedMethodsInControllersReview < ::RailsBestPractices::Reviews::Review
  include ::RailsBestPractices::Core::Check::Classable
  include ::RailsBestPractices::Core::Check::Moduleable
  include ::RailsBestPractices::Core::Check::Callable
  include ::RailsBestPractices::Core::Check::Exceptable
  include ::RailsBestPractices::Core::Check::InheritedResourcesable

  # @return [RemoveUnusedMethodsInControllersReview] a new instance of RemoveUnusedMethodsInControllersReview
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/remove_unused_methods_in_controllers_review.rb#27
  def initialize(options = T.unsafe(nil)); end

  # source://rails_best_practices//lib/rails_best_practices/core/check.rb#360
  def except_methods; end

  # source://rails_best_practices//lib/rails_best_practices/core/check.rb#365
  def excepted?(method); end

  # skip render and around_filter nodes for start_command callbacks.
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/remove_unused_methods_in_controllers_review.rb#48
  def skip_command_callback_nodes; end

  protected

  # source://rails_best_practices//lib/rails_best_practices/reviews/remove_unused_methods_in_controllers_review.rb#116
  def internal_except_methods; end

  # source://rails_best_practices//lib/rails_best_practices/reviews/remove_unused_methods_in_controllers_review.rb#121
  def mark_publicize(method_name, class_name = T.unsafe(nil)); end

  # source://rails_best_practices//lib/rails_best_practices/reviews/remove_unused_methods_in_controllers_review.rb#112
  def methods; end

  private

  # source://rails_best_practices//lib/rails_best_practices/core/check.rb#312
  def call_method(method_name, class_name = T.unsafe(nil)); end

  # source://rails_best_practices//lib/rails_best_practices/core/check.rb#297
  def mark_used(method_node); end
end

# source://rails_best_practices//lib/rails_best_practices/reviews/remove_unused_methods_in_controllers_review.rb#25
RailsBestPractices::Reviews::RemoveUnusedMethodsInControllersReview::INHERITED_RESOURCES_METHODS = T.let(T.unsafe(nil), Array)

# Find out unused methods in helpers.
#
# Implementation:
#
# Review process:
#   remember all method calls in helpers.
#   if they are not called in views, helpers, or controllers
#   then they are unused methods in helpers.
#
# source://rails_best_practices//lib/rails_best_practices/reviews/remove_unused_methods_in_helpers_review.rb#13
class RailsBestPractices::Reviews::RemoveUnusedMethodsInHelpersReview < ::RailsBestPractices::Reviews::Review
  include ::RailsBestPractices::Core::Check::Moduleable
  include ::RailsBestPractices::Core::Check::Callable
  include ::RailsBestPractices::Core::Check::Exceptable

  # @return [RemoveUnusedMethodsInHelpersReview] a new instance of RemoveUnusedMethodsInHelpersReview
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/remove_unused_methods_in_helpers_review.rb#20
  def initialize(options = T.unsafe(nil)); end

  # source://rails_best_practices//lib/rails_best_practices/core/check.rb#360
  def except_methods; end

  # source://rails_best_practices//lib/rails_best_practices/core/check.rb#365
  def excepted?(method); end

  # source://rails_best_practices//lib/rails_best_practices/core/check.rb#231
  def skip_command_callback_nodes; end

  protected

  # source://rails_best_practices//lib/rails_best_practices/reviews/remove_unused_methods_in_helpers_review.rb#43
  def internal_except_methods; end

  # source://rails_best_practices//lib/rails_best_practices/reviews/remove_unused_methods_in_helpers_review.rb#39
  def methods; end

  private

  # source://rails_best_practices//lib/rails_best_practices/core/check.rb#312
  def call_method(method_name, class_name = T.unsafe(nil)); end

  # source://rails_best_practices//lib/rails_best_practices/core/check.rb#297
  def mark_used(method_node); end
end

# Find out unused methods in models.
#
# Implemenation:
#
# Review process:
#   remember all method calls,
#   at end, check if all defined methods are called,
#   if not, non called methods are unused.
#
# source://rails_best_practices//lib/rails_best_practices/reviews/remove_unused_methods_in_models_review.rb#13
class RailsBestPractices::Reviews::RemoveUnusedMethodsInModelsReview < ::RailsBestPractices::Reviews::Review
  include ::RailsBestPractices::Core::Check::Classable
  include ::RailsBestPractices::Core::Check::Callable
  include ::RailsBestPractices::Core::Check::Exceptable

  # @return [RemoveUnusedMethodsInModelsReview] a new instance of RemoveUnusedMethodsInModelsReview
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/remove_unused_methods_in_models_review.rb#21
  def initialize(options = T.unsafe(nil)); end

  # source://rails_best_practices//lib/rails_best_practices/core/check.rb#360
  def except_methods; end

  # source://rails_best_practices//lib/rails_best_practices/core/check.rb#365
  def excepted?(method); end

  # skip scope and validate nodes for start_command callbacks.
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/remove_unused_methods_in_models_review.rb#27
  def skip_command_callback_nodes; end

  protected

  # source://rails_best_practices//lib/rails_best_practices/reviews/remove_unused_methods_in_models_review.rb#97
  def internal_except_methods; end

  # source://rails_best_practices//lib/rails_best_practices/reviews/remove_unused_methods_in_models_review.rb#93
  def methods; end

  private

  # source://rails_best_practices//lib/rails_best_practices/core/check.rb#312
  def call_method(method_name, class_name = T.unsafe(nil)); end

  # source://rails_best_practices//lib/rails_best_practices/core/check.rb#297
  def mark_used(method_node); end
end

# Review a controller file to make sure that complex model creation should not exist in
# controller, should be replaced with factory method.
#
# See the best practice details here https://rails-bestpractices.com/posts/2010/07/21/replace-complex-creation-with-factory-method/
#
# Implementation:
#
# Review process:
#   check all method defines in the controller files,
#   if there are multiple attribute assignments apply to one receiver,
#   and the receiver is a variable,
#   and after them there is a call node with message "save" or "save!",
#   then these attribute assignments are complex creation, should be replaced with factory method.
#
# source://rails_best_practices//lib/rails_best_practices/reviews/replace_complex_creation_with_factory_method_review.rb#18
class RailsBestPractices::Reviews::ReplaceComplexCreationWithFactoryMethodReview < ::RailsBestPractices::Reviews::Review
  # @return [ReplaceComplexCreationWithFactoryMethodReview] a new instance of ReplaceComplexCreationWithFactoryMethodReview
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/replace_complex_creation_with_factory_method_review.rb#23
  def initialize(options = T.unsafe(nil)); end

  private

  # check the call node to see if it is with message "save" or "save!",
  # and the count attribute assignment on the receiver of the call node is greater than @assign_count defined,
  # then it is a complex creation, should be replaced with factory method.
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/replace_complex_creation_with_factory_method_review.rb#55
  def check_variable_save(node); end
end

# Review a partail view file to make sure there is no instance variable.
#
# See the best practice details here https://rails-bestpractices.com/posts/2010/07/24/replace-instance-variable-with-local-variable/
#
# Implementation:
#
# Review process:
#   check all instance variable in partial view files,
#   if exist, then they should be replaced with local variable
#
# source://rails_best_practices//lib/rails_best_practices/reviews/replace_instance_variable_with_local_variable_review.rb#14
class RailsBestPractices::Reviews::ReplaceInstanceVariableWithLocalVariableReview < ::RailsBestPractices::Reviews::Review; end

# Review a route file to make sure all auto-generated routes have corresponding actions in controller.
#
# See the best practice details here https://rails-bestpractices.com/posts/2011/08/19/restrict-auto-generated-routes/
#
# Implementation:
#
# Review process:
#   check all resources and resource method calls,
#   compare the generated routes and corresponding actions in controller,
#   if there is a route generated, but there is not action in that controller,
#   then you should restrict your routes.
#
# source://rails_best_practices//lib/rails_best_practices/reviews/restrict_auto_generated_routes_review.rb#16
class RailsBestPractices::Reviews::RestrictAutoGeneratedRoutesReview < ::RailsBestPractices::Reviews::Review
  # @return [RestrictAutoGeneratedRoutesReview] a new instance of RestrictAutoGeneratedRoutesReview
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/restrict_auto_generated_routes_review.rb#33
  def initialize(options = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/restrict_auto_generated_routes_review.rb#92
  def check_method_add_block?(node); end

  # source://rails_best_practices//lib/rails_best_practices/reviews/restrict_auto_generated_routes_review.rb#21
  def resource_methods; end

  # source://rails_best_practices//lib/rails_best_practices/reviews/restrict_auto_generated_routes_review.rb#29
  def resources_methods; end

  private

  # source://rails_best_practices//lib/rails_best_practices/reviews/restrict_auto_generated_routes_review.rb#134
  def _check(node, methods); end

  # source://rails_best_practices//lib/rails_best_practices/reviews/restrict_auto_generated_routes_review.rb#152
  def _methods(node, methods); end

  # check resource call, if the routes generated by resources does not exist in the controller.
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/restrict_auto_generated_routes_review.rb#104
  def check_resource(node); end

  # check resources call, if the routes generated by resources does not exist in the controller.
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/restrict_auto_generated_routes_review.rb#99
  def check_resources(node); end

  # get the controller name.
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/restrict_auto_generated_routes_review.rb#109
  def controller_name(node); end

  # source://rails_best_practices//lib/rails_best_practices/reviews/restrict_auto_generated_routes_review.rb#186
  def friendly_route_name(node); end

  # @return [Boolean]
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/restrict_auto_generated_routes_review.rb#182
  def hash_key_exist?(node, key); end

  # source://rails_best_practices//lib/rails_best_practices/reviews/restrict_auto_generated_routes_review.rb#171
  def module_option(node); end

  # get the class name with namespace.
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/restrict_auto_generated_routes_review.rb#125
  def namespaced_class_name(name); end

  # source://rails_best_practices//lib/rails_best_practices/reviews/restrict_auto_generated_routes_review.rb#178
  def option_with_hash(node); end
end

# A Review class that takes charge of reviewing one rails best practice.
#
# source://rails_best_practices//lib/rails_best_practices/reviews/review.rb#6
class RailsBestPractices::Reviews::Review < ::RailsBestPractices::Core::Check
  # get the model associations from Prepares.
  #
  # @return [Hash]
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/review.rb#53
  def model_associations; end

  # get the model attributes from Prepares.
  #
  # @return [Hash]
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/review.rb#60
  def model_attributes; end

  # get the models from Prepares.
  #
  # @return [Array]
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/review.rb#46
  def models; end

  # remember use count for the variable in the call or assign node.
  #
  # find the variable in the call or assign node,
  # then save it to as key in @variable_use_count hash, and add the call count (hash value).
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/review.rb#14
  def remember_variable_use_count(node); end

  # reset @variable_use_count hash.
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/review.rb#29
  def reset_variable_use_count; end

  # find variable in the call or field node.
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/review.rb#34
  def variable(node); end

  # return @variable_use_count hash.
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/review.rb#24
  def variable_use_count; end
end

# Review a controller file to make sure using simplified syntax for render.
#
# See the best practice details here https://rails-bestpractices.com/posts/2010/12/12/simplify-render-in-controllers/
#
# Implementation:
#
# Review process:
#   check all render method commands in controller files,
#   if there is a key 'action', 'template' or 'file' in the argument,
#   then they should be replaced by simplified syntax.
#
# source://rails_best_practices//lib/rails_best_practices/reviews/simplify_render_in_controllers_review.rb#15
class RailsBestPractices::Reviews::SimplifyRenderInControllersReview < ::RailsBestPractices::Reviews::Review; end

# Review a view file to make sure using simplified syntax for render.
#
# See the best practice details here https://rails-bestpractices.com/posts/2010/12/04/simplify-render-in-views/
#
# Implementation:
#
# Review process:
#   check all render method commands in view files,
#   if there is a key 'partial' in the argument, then they should be replaced by simplified syntax.
#
# source://rails_best_practices//lib/rails_best_practices/reviews/simplify_render_in_views_review.rb#14
class RailsBestPractices::Reviews::SimplifyRenderInViewsReview < ::RailsBestPractices::Reviews::Review
  protected

  # @return [Boolean]
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/simplify_render_in_views_review.rb#36
  def include_partial?(hash_node); end

  # @return [Boolean]
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/simplify_render_in_views_review.rb#40
  def valid_hash?(hash_node); end
end

# source://rails_best_practices//lib/rails_best_practices/reviews/simplify_render_in_views_review.rb#19
RailsBestPractices::Reviews::SimplifyRenderInViewsReview::VALID_KEYS = T.let(T.unsafe(nil), Array)

# Review a controller file to make sure to use before_filter to remove duplicated first code
# line_number in different action.
#
# See the best practice detailed here https://rails-bestpractices.com/posts/2010/07/24/use-before_filter/
#
# Implementation:
#
# Review process:
#   check all first code line_number in method definitions (actions),
#   if they are duplicated, then they should be moved to before_filter.
#
# source://rails_best_practices//lib/rails_best_practices/reviews/use_before_filter_review.rb#16
class RailsBestPractices::Reviews::UseBeforeFilterReview < ::RailsBestPractices::Reviews::Review
  # @return [UseBeforeFilterReview] a new instance of UseBeforeFilterReview
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/use_before_filter_review.rb#21
  def initialize(options = T.unsafe(nil)); end

  private

  # check method define node, and remember the first sentence.
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/use_before_filter_review.rb#53
  def remember_first_sentence(node); end
end

# review a controller file to make sure to use model association instead of foreign key id assignment.
#
# See the best practice details here https://rails-bestpractices.com/posts/2010/07/19/use-model-association/
#
# Implementation:
#
# Review process:
#   check model define nodes in all controller files,
#   if there is an attribute assignment node with message xxx_id=,
#   and after it, there is a call node with message "save" or "save!",
#   and the receivers of attribute assignment node and call node are the same,
#   then model association should be used instead of xxx_id assignment.
#
# source://rails_best_practices//lib/rails_best_practices/reviews/use_model_association_review.rb#17
class RailsBestPractices::Reviews::UseModelAssociationReview < ::RailsBestPractices::Reviews::Review
  private

  # check an attribute assignment node, if its message is xxx_id,
  # then remember the receiver of the attribute assignment in @assignments.
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/use_model_association_review.rb#48
  def attribute_assignment(node); end

  # check a call node with message "save" or "save!",
  # if the receiver of call node exists in @assignments,
  # then the attribute assignment should be replaced by using model association.
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/use_model_association_review.rb#58
  def call_assignment(node); end
end

# Make sure to use multipart/alternative as content_type of email.
#
# See the best practice details here https://rails-bestpractices.com/posts/2010/08/05/use-multipart-alternative-as-content_type-of-email/
#
# Implementation:
#
# Review process:
#   check class node to remember the class name,
#   and check the method definition nodes to see if the corresponding mailer views exist or not.
#
# source://rails_best_practices//lib/rails_best_practices/reviews/use_multipart_alternative_as_content_type_of_email_review.rb#15
class RailsBestPractices::Reviews::UseMultipartAlternativeAsContentTypeOfEmailReview < ::RailsBestPractices::Reviews::Review
  private

  # the view directory of mailer.
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/use_multipart_alternative_as_content_type_of_email_review.rb#57
  def mailer_directory; end

  # all mail view files for a method name.
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/use_multipart_alternative_as_content_type_of_email_review.rb#52
  def mailer_files(name); end

  # check if rails3's syntax mailer views are canonical.
  #
  # @param name [String] method name in action_mailer
  # @return [Boolean]
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/use_multipart_alternative_as_content_type_of_email_review.rb#43
  def rails3_canonical_mailer_views?(name); end

  # check if rails's syntax mailer views are canonical.
  #
  # @param name [String] method name in action_mailer
  # @return [Boolean]
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/use_multipart_alternative_as_content_type_of_email_review.rb#38
  def rails_canonical_mailer_views?(name); end
end

# Make sure to use observer (sorry we only check the mailer deliver now).
#
# See the best practice details here https://rails-bestpractices.com/posts/2010/07/24/use-observer/
#
# TODO: we need a better solution, any suggestion?
#
# Implementation:
#
# Review process:
#   check all command nodes to see if they are callback definitions, like after_create, before_destroy,
#   if so, remember the callback methods.
#
#   check all method define nodes to see
#   if the method is a callback method,
#   and there is a mailer deliver call,
#   then the method should be replaced by using observer.
#
# source://rails_best_practices//lib/rails_best_practices/reviews/use_observer_review.rb#21
class RailsBestPractices::Reviews::UseObserverReview < ::RailsBestPractices::Reviews::Review
  # @return [UseObserverReview] a new instance of UseObserverReview
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/use_observer_review.rb#26
  def initialize(options = T.unsafe(nil)); end

  private

  # check a defn node to see if the method name exists in the @callbacks.
  #
  # @return [Boolean]
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/use_observer_review.rb#64
  def callback_method?(node); end

  # check a def node to see if it contains a actionmailer deliver call.
  #
  # if the message of call node is deliver,
  # and the receiver of the call node is with receiver node who exists in @callbacks,
  # then the call node is actionmailer deliver call.
  #
  # @return [Boolean]
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/use_observer_review.rb#73
  def deliver_mailer?(node); end

  # source://rails_best_practices//lib/rails_best_practices/reviews/use_observer_review.rb#85
  def mailers; end

  # check a command node, if it is a callback definition, such as after_create, before_create,
  # then save the callback methods in @callbacks
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/use_observer_review.rb#54
  def remember_callback(node); end
end

# Check if method definition has parentheses around parameters.
#
# Review process:
#   check def node in all files,
#   if params node with values, but not wrapped by paren node,
#   then it should use parentheses around parameters.
#
# source://rails_best_practices//lib/rails_best_practices/reviews/use_parentheses_in_method_def_review.rb#11
class RailsBestPractices::Reviews::UseParenthesesInMethodDefReview < ::RailsBestPractices::Reviews::Review
  protected

  # @return [Boolean]
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/use_parentheses_in_method_def_review.rb#28
  def has_parameters?(def_node); end

  # @return [Boolean]
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/use_parentheses_in_method_def_review.rb#24
  def no_parentheses_around_parameters?(def_node); end
end

# Make sure to use query attribute instead of nil?, blank? and present?.
#
# See the best practice details here https://rails-bestpractices.com/posts/2010/10/03/use-query-attribute/
#
# Implementation:
#
# Review process:
#   check all method calls within conditional statements, like @user.login.nil?
#   if their receivers are one of the model names
#   and their messages of first call are not pluralize and not in any of the association names
#   and their messages of second call are one of nil?, blank?, present?, or they are == ""
#   then you can use query attribute instead.
#
# source://rails_best_practices//lib/rails_best_practices/reviews/use_query_attribute_review.rb#17
class RailsBestPractices::Reviews::UseQueryAttributeReview < ::RailsBestPractices::Reviews::Review
  private

  # check if the node is with node type :binary, node message :== and node argument is empty string.
  #
  # @return [Boolean]
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/use_query_attribute_review.rb#113
  def compare_with_empty_string?(node); end

  # check if the receiver is one of the models.
  #
  # @return [Boolean]
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/use_query_attribute_review.rb#97
  def is_model?(variable_node); end

  # check if the receiver and message is one of the model's attribute.
  # the receiver should match one of the class model name, and the message should match one of attribute name.
  #
  # @return [Boolean]
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/use_query_attribute_review.rb#106
  def model_attribute?(variable_node, message); end

  # check if the node may use query attribute instead.
  #
  # if the node contains two method calls, e.g. @user.login.nil?
  #
  # for the first call, the receiver should be one of the class names and
  # the message should be one of the attribute name.
  #
  # for the second call, the message should be one of nil?, blank? or present? or
  # it is compared with an empty string.
  #
  # the node that may use query attribute.
  #
  # @return [Boolean]
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/use_query_attribute_review.rb#86
  def possible_query_attribute?(node); end

  # recursively check conditional statement nodes to see if there is a call node that may be
  # possible query attribute.
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/use_query_attribute_review.rb#57
  def query_attribute_node(conditional_statement_node); end
end

# source://rails_best_practices//lib/rails_best_practices/reviews/use_query_attribute_review.rb#22
RailsBestPractices::Reviews::UseQueryAttributeReview::QUERY_METHODS = T.let(T.unsafe(nil), Array)

# Review a migration file to make sure to use say or say_with_time for customized data changes
# to produce a more readable output.
#
# See the best practice detials here https://rails-bestpractices.com/posts/2010/08/19/use-say-and-say_with_time-in-migrations-to-make-a-useful-migration-log/
#
# Implementation:
#
# Review process:
#   check class method define nodes (self.up or self.down).
#   if there is a method call in the class method definition,
#   and the message of method call is not say, say_with_time and default migration methods
#   (such as add_column and create_table), then the method call should be wrapped by say or say_with_time.
#
# source://rails_best_practices//lib/rails_best_practices/reviews/use_say_with_time_in_migrations_review.rb#17
class RailsBestPractices::Reviews::UseSayWithTimeInMigrationsReview < ::RailsBestPractices::Reviews::Review; end

# source://rails_best_practices//lib/rails_best_practices/reviews/use_say_with_time_in_migrations_review.rb#22
RailsBestPractices::Reviews::UseSayWithTimeInMigrationsReview::WITH_SAY_METHODS = T.let(T.unsafe(nil), Array)

# Review a controller to make sure to use scope access instead of manually checking current_user and redirect.
#
# See the best practice details here https://rails-bestpractices.com/posts/2010/07/20/use-scope-access/
#
# Implementation:
#
# Review process:
#   check all if nodes to see
#
#   if they are compared with current_user or current_user.id,
#   and there is redirect_to method call in if block body,
#   then it should be replaced by using scope access.
#
# source://rails_best_practices//lib/rails_best_practices/reviews/use_scope_access_review.rb#17
class RailsBestPractices::Reviews::UseScopeAccessReview < ::RailsBestPractices::Reviews::Review
  private

  # check a call node to see if it uses current_user, or current_user.id.
  #
  # @return [Boolean]
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/use_scope_access_review.rb#54
  def current_user?(node); end

  # check a if node to see
  #
  # if the conditional statement is compared with current_user or current_user.id,
  # and there is a redirect_to method call in the block body,
  # then it should be replaced by using scope access.
  #
  # @return [Boolean]
  #
  # source://rails_best_practices//lib/rails_best_practices/reviews/use_scope_access_review.rb#38
  def current_user_redirect?(node); end
end

# Prepare Gemfile and review Capfile file to make sure using turbo-sprocket-rails3
#
# See the best practice details here https://rails-bestpractices.com/posts/2012/11/23/speed-up-assets-precompile-with-turbo-sprockets-rails3/
#
# Implementation:
#
# Review process:
#   only check if turbo-sprockets-rails3 gem is not used and load 'deploy/assets' in Capfile.
#
# source://rails_best_practices//lib/rails_best_practices/reviews/use_turbo_sprockets_rails3_review.rb#13
class RailsBestPractices::Reviews::UseTurboSprocketsRails3Review < ::RailsBestPractices::Reviews::Review; end
